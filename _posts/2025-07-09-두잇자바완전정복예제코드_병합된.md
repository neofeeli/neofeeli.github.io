---
layout: post
read_time: true
show_date: true
title: "2025-07-09-두잇자바완전정복예제코드_병합된"
date: 2025-07-09
img: ""
tags: [java, 자바, 책, book]
category: opinion
author: 정대호
description: "2025-07-09-두잇자바완전정복예제코드_병합된"
---

```java

chap01_basicsyntax-master\src\sec01_basicsyntax\EX01_JavaBasicStructure\JavaBasicStructure.java"
package sec01_basicsyntax.EX01_JavaBasicStructure;

/*생성 프로젝트 기본 구조*/

/* ctrl+shift+'/'
     처음 만든 클래스
   (여러 줄 주석)
*/

public class JavaBasicStructure {

	public static void main(String[] args) {

		//한줄주석 : 화면 출력 코드 ctrl+'/'
		System.out.println("콘솔 화면에 출력");

	}

}

chap01_basicsyntax-master\src\sec01_basicsyntax\EX02_ByteCodeFiles\ByteCodeFiles.java"
package sec01_basicsyntax.EX02_ByteCodeFiles;

/*컴파일이후 생성되는 실행파일(.class)*/

class A { //A.class

}
class B { //B.class

}
class C { //C.class
	class D { //C$D.class

	}
}

public class ByteCodeFiles { //ByteCodeFiles.class

}

chap01_basicsyntax-master\src\sec01_basicsyntax\EX03_ConsoleOutput\ConsoleOutput.java"
package sec01_basicsyntax.EX03_ConsoleOutput;

/*기본적인 콘솔 출력 방법*/

public class ConsoleOutput {

	public static void main(String[] ar) {

		// #1. System.out.println(...)
		System.out.println("안녕하세요");
		System.out.println("안녕" + "하세요");
		System.out.println(2 + 4);
		System.out.println(4.6);
		System.out.println("문자" + 1);
		System.out.println("문자" + 1 + 2);
		System.out.println(1 + 2 + "문자");
		System.out.println();
		int a = 5;
		String b = "하세요";
		System.out.println(a);
		System.out.println(b);
		System.out.println("안녕"+b);
		System.out.println(a + "안녕" + b);
		System.out.println();
		// #2. System.out.print(...)
		System.out.print("반갑");
		System.out.print("습니다");
		System.out.print("7");
		System.out.print("\n");
		System.out.print("\n");
		// #3. System.out.printf(...)
		System.out.printf("%d\n", 10);
		System.out.printf("%o\n", 10);
		System.out.printf("%x\n", 10);
		System.out.printf("%s\n", "문자열 출력");
		System.out.printf("%f\n", 3.2582);
		System.out.printf("%4.2f\n", 3.2582);
		System.out.printf("%d와 %4.2f\n", 10, 3.2582);

	}

}











chap02_datatypeandprimarydatatype-master\src\sec01_datatype\EX03_RangeOfVariableUse\RangeOfVariableUse.java"
package sec01_datatype.EX03_RangeOfVariableUse;

/*변수의 생존기간*/

public class RangeOfVariableUse {
    public static void main(String[] args) {
        int value1 = 3;
        {
            int value2 = 5;
            System.out.println(value1);	//3
            System.out.println(value2);	//5
        }

        System.out.println(value1);		//3
        //System.out.println(value2);	//오류
    }
}


chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX01_FloatVsDouble\FloatVsDouble.java"
package sec02_primarydatatype.EX01_FloatVsDouble;

/*float과 double의 정밀도 비교*/

public class FloatVsDouble {
    public static void main(String[] args) {
        //#1. float의 정밀도 (대략 소수 7자리)
        float f1 = 1.0000001f;
        System.out.println(f1);
        float f2 = 1.00000001f;
        System.out.println(f2);

        //#2. double의 정밀도 (대략 소수 15자리)
        double d1 = 1.000000000000001;
        System.out.println(d1);
        double d2 = 1.0000000000000001;
        System.out.println(d2);
    }
}

chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX02_PrimaryDataType_1\PrimaryDataType_1.java"
package sec02_primarydatatype.EX02_PrimaryDataType_1;

/*부울대수/정수/실수 값의 저장 및 출력*/

public class PrimaryDataType_1 {
    public static void main(String[] args) {
        //#1. boolean : true / false
        boolean bool1 = true;
        boolean bool2 = false;
        System.out.println(bool1); //true
        System.out.println(bool2); //false
        System.out.println();

        //#2. 정수 (byte, short, int, long) : 음의 정수 / 0 / 양의 정수
        byte value1 = 10;
        short value2 = -10;
        int value3 = 100;
        long value4 = -100L;
        System.out.println(value1); //10
        System.out.println(value2); //-10
        System.out.println(value3); //100
        System.out.println(value4); //-100
        System.out.println();

        //#3. 실수 (float, double) : 음의 실수 / 0 / 양의 실수
        float value5 = 1.2F;
        double value6 = -1.5;
        double value7 = 5;
        System.out.println(value5); //1.2
        System.out.println(value6); //-1.5
        System.out.println(value7); //5.0
    }
}

chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX03_PrimaryDataType_2\PrimaryDataType_2.java"
package sec02_primarydatatype.EX03_PrimaryDataType_2;

/*문자 값의 다양한 저장방법 및 출력*/

public class PrimaryDataType_2 {
    public static void main(String[] args) {

        //#4. 문자(char) : 문자, 정수
        //#4-1. 문자로 저장하는 방법
        char value1 = 'A';
        char value2 = '가';
        char value3 = '3';
        System.out.println(value1); //A
        System.out.println(value2); //가
        System.out.println(value3); //3
        System.out.println();

        //#4-2. 정수로 저장하는 방법
        char value4 = 65;
        char value5 = 0xac00;
        char value6 = 51;
        System.out.println(value4); //A
        System.out.println(value5); //가
        System.out.println(value6); //3
        System.out.println();

        //#4-3. 유니코드로 직접 입력
        char value7 = '\u0041';
        char value8 = '\uac00';
        char value9 = '\u0033';
        System.out.println(value7); //A
        System.out.println(value8); //가
        System.out.println(value9); //3
    }
}

chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX04_TypeCasting_1\TypeCasting_1.java"
package sec02_primarydatatype.EX04_TypeCasting_1;

/*두 가지 타입 변환 방법*/

public class TypeCasting_1 {
    public static void main(String[] args) {
        //#1. 캐스팅 방법
        //@1-1 캐스팅 방법 1 (데이터타입)
        int value1 = (int)5.3;
        long value2 = (long)10;
        float value3 = (float)5.8;
        double value4 = (double)16;

        System.out.println(value1); //5
        System.out.println(value2); //10
        System.out.println(value3); //5.8
        System.out.println(value4); //16.0
        System.out.println();

        //@1-2 캐스팅 방법 2 (L, F)
        long value5 = 10L;
        long value6 = 10l;
        float value7 = 5.8F;
        float value8 = 5.8f;

        System.out.println(value5); //10
        System.out.println(value6); //10
        System.out.println(value7); //5.8
        System.out.println(value8); //5.8
    }
}

chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX05_TypeCasting_2\TypeCasting_2.java"
package sec02_primarydatatype.EX05_TypeCasting_2;

/*자동타입변환과 수동타입변환*/

public class TypeCasting_2 {
    public static void main(String[] args) {
        //#1. 자동타입변환 (업캐스팅 + byte/short 자료형 데이터 입력)
        float value1 = 3;	//int -> float (업캐스팅)
        long value2 = 5;	//int -> long (업캐스팅)
        double value3 = 7;	//int -> double (업캐스팅)
        byte value4 = 9; 	//(예외: int -> byte)
        short value5 = 11;	//(예외: int -> short)

        System.out.println(value1);
        System.out.println(value2);
        System.out.println(value3);
        System.out.println(value4);
        System.out.println(value5);
        System.out.println();

        //#2. 수동 타입변환
        byte value6 = (byte)128; 	//int -> byte (다운캐스팅)
        int value7 = (int)3.5;   	//double -> int (다운캐스팅)
        float value8 = (float)7.5;	//double -> float (다운캐스팅)

        System.out.println(value6);
        System.out.println(value7);
        System.out.println(value8);
    }
}














chap02_datatypeandprimarydatatype-master\src\sec02_primarydatatype\EX06_OperationBetweenDataType\OperationBetweenDataType.java"
package sec02_primarydatatype.EX06_OperationBetweenDataType;

/*같은 자료형간의 연산과 다른 자료형간의 연산*/

public class OperationBetweenDataType {
    public static void main(String[] args) {
        //#1.같은 자료형간의 연산
        int value1 = 3+5;
        int value2 = 8/5; 			//1
        float value3 = 3.0f + 5.0f;
        double value4 = 8.0/5.0; 	//1.6

        byte data1 = 3;
        byte data2 = 5;
        //byte value5 = data1 + data2; //오류
        int value5 = data1 + data2;

        System.out.println(value1);
        System.out.println(value2);
        System.out.println(value3);
        System.out.println(value4);
        System.out.println(value5);
        System.out.println();

        //#2.다른 자료형간의 연산
        //int value6 = 5 + 3.5;	//오류
        double value6 = 5 + 3.5;
        int value7 =  5 + (int)3.5;

        double value8 = 5/2.0;
        byte data3 = 3;
        short data4 = 5;
        int value9 = data3 + data4;
        double value10 = data3 + data4;

        System.out.println(value6);
        System.out.println(value7);
        System.out.println(value8);
        System.out.println(value9);
        System.out.println(value10);
    }
}
chap03_operators-master\src\sec01_operator_1\EX03_ShiftOperator\ShiftOperator.java"
package sec01_operator_1.EX03_ShiftOperator;

/*산술쉬프트와 논리쉬프트*/

public class ShiftOperator {
    public static void main(String[] args) {
        //#1.산술쉬프트(부호변화가 없음 *2, /2 효과)
        //@ << Left shift
        System.out.println(3<<1); //6
        System.out.println(-3<<1);//-6
        System.out.println(3<<2); //12
        System.out.println(-3<<2);//-12
        System.out.println();

        //@ >> Right shift
        System.out.println(5>>1); //2
        System.out.println(-5>>1);//-3
        System.out.println(5>>2); //1
        System.out.println(-5>>2);//-2
        System.out.println();

        //#2. 논리쉬프트 (>>>)
        System.out.println(3>>>1); //0000...0011 = 1
        System.out.println(-3>>>31); //1111...1101 = 1
    }
}

chap03_operators-master\src\sec01_operator_1\EX04_RelationOperator\RelationOperator.java"
package sec01_operator_1.EX04_RelationOperator;

/*크기비교 및 등가비교와 참조자료형의 등가비교*/

public class RelationOperator {
    public static void main(String[] args) {
        //#1. 크기비교 (<, >, <=, >=) : true, false
        System.out.println(5<2); //false
        System.out.println(5>2); //true
        System.out.println(5<5); //false
        System.out.println(5<=5); //true
        System.out.println(5>=5); //true
        System.out.println();

        //#2. 등가비교(==, !=) : true, false
        //@ 기본자료형 등가비교 (값비교)
        int a = 5;
        int b = 2;
        int c = 5;
        System.out.println(a==b); //false
        System.out.println(a!=b); //true
        System.out.println(a==c); //true
        System.out.println(a!=c); //false
        System.out.println();

        //@ 참조자료형 등가비교 (번지비교)
        String str1 = new String("안녕");
        String str2 = new String("안녕");
        System.out.println(str1 == str2); //false
    }
}

chap03_operators-master\src\sec01_operator_1\EX05_LogicalOperator\LogicalOperator.java"
package sec01_operator_1.EX05_LogicalOperator;

/*논리연산자와 비트연산자를 이용한 논리연산*/

public class LogicalOperator {
    public static void main(String[] args) {
        //#1.논리연산자
        //@AND (&&)
        System.out.println(true && true); //true
        System.out.println(true && false); //false
        System.out.println(true && (5<3)); //false
        System.out.println((5<=5) && (7>2)); //true
        System.out.println();

        //@OR (||)
        System.out.println(true || true); //true
        System.out.println(true || false); //true
        System.out.println(false || (5<3)); //false
        System.out.println((5<=5) || (7>2)); //true
        System.out.println();

        //@XOR (^)
        System.out.println(true ^ true); //false
        System.out.println(true ^ false); //true
        System.out.println(false ^ (5<3)); //false
        System.out.println((5<=5) ^ (7>2)); //false
        System.out.println();

        //@NOT (!)
        System.out.println(!true); //false
        System.out.println(!false); //true
        System.out.println(false || !(5<3)); //true
        System.out.println((5<=5) || !(7>2)); //true

        //#2. 비트연산자로 논리연산 수행
        System.out.println(true & true); //true
        System.out.println(true & false); //false
        System.out.println(true | (5<3)); //true
        System.out.println((5<=5) | (7>2)); //true
        System.out.println();

        //@숏 서킷 사용 여부 (논리연산자는 O, 비트연산자 X)
        int value1 = 3;
        System.out.println(false && ++value1>6); //false
        System.out.println(value1); //3

        int value2 = 3;
        System.out.println(false & ++value2>6); //false
        System.out.println(value2); //4

        int value3 = 3;
        System.out.println(true || ++value3>6); //true
        System.out.println(value3); //3

        int value4 = 3;
        System.out.println(true | ++value4>6); //true
        System.out.println(value4); //4
    }
}













chap03_operators-master\src\sec01_operator_1\EX06_AssignmentOperator\AssignmentOperator.java"
package sec01_operator_1.EX06_AssignmentOperator;

/*대입연산자 및 축약표현*/

public class AssignmentOperator {
    public static void main(String[] args) {
        //#1. 대입연산자 와 축약 표현
        //@대입연산자
        int value1 = 3;
        value1 = value1+3;
        System.out.println(value1);		//6
        System.out.println();

        //@축약표현
        int value2;
        value2 = 5; System.out.println(value2+=2);		//7
        value2 = 5; System.out.println(value2-=2);		//3
        value2 = 5; System.out.println(value2*=2);		//10
        value2 = 5; System.out.println(value2/=2);		//2
        value2 = 5; System.out.println(value2%=2);		//1
        value2 = 5; System.out.println(value2|=2);		//7
        value2 = 5; System.out.println(value2<<=2);		//20
        value2 = 5; System.out.println(value2>>=2);		//1
        value2 = 5; System.out.println(value2>>>=2);	//1
    }
}

chap03_operators-master\src\sec01_operator_1\EX07_ConditionalOperator\ConditionalOperator.java"
package sec01_operator_1.EX07_ConditionalOperator;

/*삼항 연산자*/

public class ConditionalOperator {
    public static void main(String[] args) {
        //#1. 삼항연산자
        int value1 = (3>5)? 6: 9;
        System.out.println(value1); //9

        int value2 = (5>3)? 10: 20;
        System.out.println(value2); //10

        int value3 = 3;
        System.out.println((value3%2==0)?"짝수":"홀수");

        //cf. if - else 구문으로 변환
        if(value3%2==0) {
            System.out.println("짝수");
        } else {
            System.out.println("홀수");
        }
    }
}

chap04_controlstatement-master\src\sec02_loopcontrolstatement\EX01_ForControlStatement\ForControlStatement.java"
package sec02_loopcontrolstatement.EX01_ForControlStatement;

/*for 반복제어문의 기본문법구조, 특수한 형태, 무한루프에서 탈출하기*/

public class ForControlStatement {
    public static void main(String[] args) {
        //#1. for 기본문법구조
        int a;
        for(a=0; a<3; a++) {
            System.out.print(a + " ");
        } // 0, 1, 2
        System.out.println();

        for(int i=0; i<3; i++) {
            System.out.print(i + " ");
        } // 0, 1, 2
        System.out.println();

        for(int i=0; i<100; i++) {
            System.out.print(i + " ");
        } //0~99
        System.out.println();

        for(int i=10; i>0; i--) {
            System.out.print(i + " ");
        } //10, 9, ... , 1
        System.out.println();

        for(int i=0; i<10; i+=2) {
            System.out.print(i + " ");
        } //0, 2, 4, 6, 8
        System.out.println();

        for(int i=0, j=0; i<10; i++, j++) {
            System.out.print(i + j + " ");
        } //0, 2, 4, 6, 8,.. , 18
        System.out.println();

        //#2. for문의 특수한 형태 (무한루프)
        /*
        for(int i=0; ; i++) {
            System.out.print(i + " ");
        } //0 1 2 ...
        for(;;) {
            System.out.print("무한루프");
        } //무한루프 ...
        */
        System.out.println();

        //#3. 무한루프 탈출 (break)
        for(int i=0; ;i++) {
            if(i>10) {
                break;
            }
            System.out.print(i+" ");
        }//0 ~ 10 : 11개 출력
        System.out.print("무한루프 탈출 ");
    }
}













chap04_controlstatement-master\src\sec02_loopcontrolstatement\EX02_WhileControlStatement\WhileControlStatement.java"
package sec02_loopcontrolstatement.EX02_WhileControlStatement;

/*while 반복제어문의 기본문법구조, for로 변환, 특수한 형태, 무한루프 탈출*/

public class WhileControlStatement {
    public static void main(String[] args) {
        //#1.while의 기본문법구조
        int a=0;
        while(a<10) {
            System.out.print(a +" ");
            a++;
        } // 0, 1, 2, ~ 9 : 10회
        System.out.println();

        //@for문으로 변환
        for(int i=0; i<10; i++) {
            System.out.print(i + " ");
        } // 0, 1, 2, ~ 9 : 10회
        System.out.println();

        int b=10;
        while(b>0) {
            System.out.print(b+" ");
            b--;
        } //10, 9, ~, 1 : 10회
        System.out.println();

        //@for문으로 변환
        for(int i=10; i>0; i--) {
            System.out.print(i + " ");
        } //10, 9, ~, 1 : 10회

        //#2.while의 특수한 형태(무한루프)
        /*
        while(true) {
            System.out.println("무한루프");
        }
        */
        System.out.println();

        //#3.무한루프 탈출하기 break
        int c = 0;
        while(true) {
            if(c>10) {
                break;
            }
            System.out.print(c+ " ");
            c++;
        } //0~ 10 : 11번 수행
    }
}

chap04_controlstatement-master\src\sec02_loopcontrolstatement\EX03_DoWhileControlStatement\DoWhileControlStatement.java"
package sec02_loopcontrolstatement.EX03_DoWhileControlStatement;

/*do-while의 기본문법구조, do-while vs. while의 비교*/

public class DoWhileControlStatement {
    public static void main(String[] args) {
        //#1. 반복회수가 0인 경우 do-while과 while 문 비교
        int a;
        a=0;
        while(a<0) {
            System.out.print(a+" ");
            a++;
        } // 실행회수 0번
        System.out.println();
        a=0;
        do {
            System.out.print(a+" ");
            a++;
        } while(a<0); //실행회수 1번
        System.out.println();

        //#2. 반복회수가 1인 경우 do-while과 while 문 비교
        a=0;
        while(a<1) {
            System.out.print(a+" ");
            a++;
        } // 실행회수 1번
        System.out.println();
        a=0;
        do {
            System.out.print(a+" ");
            a++;
        } while(a<1); //실행회수 1번
        System.out.println();

        //#3. 반복회수가 10인 경우 do-while과 while 문 비교
        a=0;
        while(a<10) {
            System.out.print(a+" ");
            a++;
        } // 실행회수 10번
        System.out.println();
        a=0;
        do {
            System.out.print(a+" ");
            a++;
        } while(a<10); //실행회수 10번
    }
}

chap04_controlstatement-master\src\sec03_overlappedcontrolstatement\EX01_OverlappedControlStatement\OverlappedControlStatement.java"
package sec03_overlappedcontrolstatement.EX01_OverlappedControlStatement;

/*제어문의 중복*/

public class OverlappedControlStatement {
    public static void main(String[] args) {
        //#1. if-if 중복
        int value1 = 5;
        int value2 = 3;
        if(value1>5) {
            if(value2<2) {
                System.out.println("실행1");
            }
            else {
                System.out.println("실행2");
            }
        }
        else {
            System.out.println("실행3");
        }
        System.out.println();

        //#2. switch-for 중복
        int value3 = 2;
        switch(value3) {
        case 1:
            for(int k=0; k<10; k++) {
                System.out.print(k+ " ");
            }
            break;
        case 2:
            for(int k=10; k>0; k--) {
                System.out.print(k+ " ");
            }
            break;
        //...
        }
        System.out.println();
        System.out.println();

        //#3. for-for-if 중복
        for(int i=0; i<3; i++) { //3바퀴
            for(int j=0; j<5; j++) { //5바퀴
                System.out.println(i+" "+j);
                if(i==j) {
                    System.out.println("i=j");
                }
            }
        }
    }
}


















chap04_controlstatement-master\src\sec04_controlkeyword\EX01_BreakControlKeyword\BreakControlKeyword.java"
package sec04_controlkeyword.EX01_BreakControlKeyword;

/*break 제어 키워드*/

public class BreakControlKeyword {
    public static void main(String[] args) {
        //#1. 단일 loop break 탈출
        for(int i=0; i<10; i++) {
            System.out.println(i);
            break;
        } //0

        for(int i=0; i<10; i++) {
            if(i==5) {
                break;
            }
            System.out.print(i+" ");
        } //0, 1, 2, 3, 4
        System.out.println();
        System.out.println();

        //#2. 다중(이중) loop break 탈출
        //@case1. 하나의 반복문만 탈출하는 경우
        for(int i=0; i<5; i++) {
            for(int j=0; j<5; j++) {
                if(j==2) {
                    break;
                }
                System.out.println(i+", "+j);
            }
        } //0,0 0,1 1,0, 1,1 ... 4,0 4,1
        System.out.println();

        //@case2. 다중 반복문을 한번에 탈출하는 방법 (break LABLE)
        POS1: for(int i=0; i<5; i++) {
            for(int j=0; j<5; j++) {
                if(j==2) {
                    break POS1;
                }
                System.out.println(i+", "+j);
            }
        } //0,0 0,1
		System.out.println();

		//@case2. 다중 반복문을 한번에 탈출하는 방법 (변수값을 조정)
		for(int i=0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(j==2) {
					i=100;
					break;
				}
				System.out.println(i+", "+j);
			}
		} //0,0 0,1
		System.out.println();
	}
}



















chap04_controlstatement-master\src\sec04_controlkeyword\EX02_ContinueControlKeyword\ContinueControlKeyword.java"
package sec04_controlkeyword.EX02_ContinueControlKeyword;

/*continue 제어키워드*/

public class ContinueControlKeyword {
	public static void main(String[] args) {
		//#1. 단일 루프에서의 continue
		for(int i=0; i<10; i++) {
			continue;
			//System.out.print(i+ " ");
		}

		for(int i=0; i<10; i++) {
			System.out.print(i+ " ");
			continue;
		} //0~9
		System.out.println();

		for(int i=0; i<10; i++) {
			if(i==5) {
				continue;
			}
			System.out.print(i+ " ");
		} //0~4, 6~9
		System.out.println();

		//#2. 다중(이중 루프에서의 continue)
		for(int i=0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(j==3) {
					continue;
				}
				System.out.println(i+ ", "+j);
			}
		}
		//
		System.out.println();
		POS1: for(int i=0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(j==3) {
					continue POS1;
				}
				System.out.println(i+ ", "+j);
			}
		} //
	}
}

chap05_referencedatatype-master\src\sec01_array\EX03_InitialValue\InitialValue.java"
package sec01_array.EX03_InitialValue;

/*스택메모리의 초기값과 참조자료형의 강제초기값*/

import java.util.Arrays;

public class InitialValue {
	public static void main(String[] args) {
		//#1. stack 메모리값 (강제초기화 되지 않음)
		int value1;
//		System.out.println(value1);//오류
		int[] value2;
//		System.out.println(value2);//오류

		int value3 = 0;
		System.out.println(value3); //0
		int[] value4 = null;
		System.out.println(value4); //null
		System.out.println();

		//#2. heap 메모리의 초기값 (강제초기화)
		//@기본자료형 배열
		boolean[] array1 = new boolean[3]; //false로 초기화
		for(int i=0; i<3; i++) {
			System.out.print(array1[i]+ " ");
		}
		System.out.println();

		int[] array2 = new int[3]; //0으로 초기화
		for(int i=0; i<3; i++) {
			System.out.print(array2[i]+ " ");
		}
		System.out.println();

		double[] array3 = new double[3]; //0.0으로 초기화
		for(int i=0; i<3; i++) {
			System.out.print(array3[i]+ " ");
		}
		System.out.println();

		//@참조자료형 배열
		String[] array4 = new String[3]; //null으로 초기화
		for(int i=0; i<3; i++) {
			System.out.print(array4[i]+ " ");
		}
		System.out.println();
		System.out.println();

		//Tip. 배열을 쉽게 출력할 수 있는 방법
		System.out.println(Arrays.toString(array1));
		System.out.println(Arrays.toString(array2));
		System.out.println(Arrays.toString(array3));
		System.out.println(Arrays.toString(array4));
	}
}


















chap05_referencedatatype-master\src\sec01_array\EX04_PrimaryAndReferenceType\PrimaryAndReferenceType.java"
package sec01_array.EX04_PrimaryAndReferenceType;

/*기본자료형 vs. 참조자료형의 특징 비교*/

public class PrimaryAndReferenceType {
	public static void main(String[] args) {
		//#1. 기본자료형의 대입연산 (stack 값 복사)
		int value1 = 3;
		int value2 = value1;
		value2 = 7;
		System.out.println(value1); //3
		System.out.println(value2); //7
		System.out.println();

		//#2. 참조자료형의 대입연산 (stack 값 복사)
		int[] array1 = new int[] {3, 4, 5};
		int[] array2 = array1;
		array2[0]=7;
		System.out.println(array1[0]); //7
		System.out.println(array2[0]); //7
	}
}


chap05_referencedatatype-master\src\sec01_array\EX05_ReadArrayData\ReadArrayData.java"
package sec01_array.EX05_ReadArrayData;

/*1차원 배열의 원소값 출력*/

import java.util.Arrays;

public class ReadArrayData {
	public static void main(String[] args) {
		int[] array = new int[] {3, 4, 5, 6, 7};

		//#1. 배열의 길이 구하기
		System.out.println(array.length); //5

		//#2. 출력하기 1:
		System.out.print(array[0]+" ");
		System.out.print(array[1]+" ");
		System.out.print(array[2]+" ");
		System.out.print(array[3]+" ");
		System.out.print(array[4]+" ");
		System.out.println();

		//#3. 출력하기 2:
		for(int i=0; i<array.length; i++)
			System.out.print(array[i]+" ");
		System.out.println();

		//#4. 출력하기 3:
		//for(꺼낸 하나의 원소를 저장할 수 있는 변수:집합객체) {} for each 구문
		for(int k : array) {
			System.out.print(k+" ");
		}
		System.out.println();

		//#5. 출력하기 4 :
		System.out.println(Arrays.toString(array));
	}
}














chap05_referencedatatype-master\src\sec01_array\EX06_RectangleArrayDefinition\RectangleArrayDefinition.java"
package sec01_array.EX06_RectangleArrayDefinition;

/*2차원 배열의 세 가지 선언방법과 다양한 배열 선언*/

public class RectangleArrayDefinition {
	public static void main(String[] args) {
		//#1. 배열의 선언 방법 1
		int[][] array1 = new int[3][4];
		int[][] array2;
		array2 = new int[3][4];

		//#2. 배열의 선언 방법 2
		int array3[][] = new int[3][4];
		int array4[][];
		array4 = new int[3][4];

		//#3. 배열의 선언 방법 3
		int[] array5[] = new int[3][4];
		int[] array6[];
		array6 = new int[3][4];

		//#4. 다양한 배열 선언 (기본자료형 배열, 참조자료형 배열)
		boolean[][] array7 = new boolean[3][4];
		int[][] array8 = new int[2][4];
		double[][] array9 = new double[3][5];
		String[][] array10 = new String[2][6]; //참조자료형 배열
	}
}













chap05_referencedatatype-master\src\sec01_array\EX07_RectangleValueAssignment\RectangleValueAssignment.java"
package sec01_array.EX07_RectangleValueAssignment;

/*2차원 정방행렬 배열의 4가지 배열 객체 생성 및 원소값 대입 방법*/

public class RectangleValueAssignment {
	public static void main(String[] args) {
		//#1. 배열객체의 생성 및 원소값 대입 (방법1)
		int[][] array1 = new int[2][3];
		array1[0][0]=1;
		array1[0][1]=2;
		array1[0][2]=3;
		array1[1][0]=4;
		array1[1][1]=5;
		array1[1][2]=6;

		System.out.println(array1[0][0]+ " "+array1[0][1]+ " "+array1[0][2]+ " ");
		System.out.println(array1[1][0]+ " "+array1[1][1]+ " "+array1[1][2]+ " ");
		System.out.println();

		int[][] array2;
		array2 = new int[2][3];
		array2[0][0]=1;
		array2[0][1]=2;
		array2[0][2]=3;
		array2[1][0]=4;
		array2[1][1]=5;
		array2[1][2]=6;

		System.out.println(array2[0][0]+ " "+array2[0][1]+ " "+array2[0][2]+ " ");
		System.out.println(array2[1][0]+ " "+array2[1][1]+ " "+array2[1][2]+ " ");
		System.out.println();

		//#2. 배열객체의 생성 및 원소값 대입 (방법2)
		int[][] array3 = new int[][] {{1,2,3},{4,5,6}};
		System.out.println(array3[0][0]+ " "+array3[0][1]+ " "+array3[0][2]+ " ");
		System.out.println(array3[1][0]+ " "+array3[1][1]+ " "+array3[1][2]+ " ");
		System.out.println();

		int[][] array4;
		array4 = new int[][] {{1,2,3},{4,5,6}};
		System.out.println(array4[0][0]+ " "+array4[0][1]+ " "+array4[0][2]+ " ");
		System.out.println(array4[1][0]+ " "+array4[1][1]+ " "+array4[1][2]+ " ");
		System.out.println();

		//#3. 배열객체의 생성 및 원소값 대입 (방법3)
		int[][] array5 = {{1,2,3},{4,5,6}};
		System.out.println(array5[0][0]+ " "+array5[0][1]+ " "+array5[0][2]+ " ");
		System.out.println(array5[1][0]+ " "+array5[1][1]+ " "+array5[1][2]+ " ");

		//int[][] array6;
		//array6 = {{1,2,3},{4,5,6}}; //불가능
	}
}























chap05_referencedatatype-master\src\sec01_array\EX08_NonRectangleArray\NonRectangleArray.java"
package sec01_array.EX08_NonRectangleArray;

/*2차원 비정방행렬 배열의 3가지 원소값 대입 방법*/

public class NonRectangleArray {
	public static void main(String[] args) {

		//#1. 비정방행렬의 선언 및 값 대입 방법1
		int[][] array1 = new int[2][];
		array1[0]=new int[2];
		array1[0][0]=1;
		array1[0][1]=2;
		array1[1]=new int[3];
		array1[1][0]=3;
		array1[1][1]=4;
		array1[1][2]=5;

		System.out.println(array1[0][0]+ " "+array1[0][1]);
		System.out.println(array1[1][0]+ " "+array1[1][1]+ " "+array1[1][2]);
		System.out.println();

		int[][] array2 = new int[2][];
		array2[0]=new int[] {1,2};
		array2[1]=new int[] {3,4,5};

		System.out.println(array2[0][0]+ " "+array2[0][1]);
		System.out.println(array2[1][0]+ " "+array2[1][1]+ " "+array2[1][2]);
		System.out.println();

		//#2. 비정방행렬의 선언 및 값 대입 방법2
		int[][] array3 = new int[][] {{1,2},{3,4,5}};
		System.out.println(array3[0][0]+ " "+array3[0][1]);
		System.out.println(array3[1][0]+ " "+array3[1][1]+ " "+array3[1][2]);
		System.out.println();

		int[][] array4;
		array4 = new int[][] {{1,2},{3,4,5}};
		System.out.println(array4[0][0]+ " "+array4[0][1]);
		System.out.println(array4[1][0]+ " "+array4[1][1]+ " "+array4[1][2]);
		System.out.println();

		//#3. 비정방행렬의 선언 및 값 대입 방법3
		int[][] array5 = {{1,2},{3,4,5}};
		System.out.println(array5[0][0]+ " "+array5[0][1]);
		System.out.println(array5[1][0]+ " "+array5[1][1]+ " "+array5[1][2]);
		System.out.println();

//		int[][] array6;
//		array6 = {{1,2},{3,4,5}}; //불가능
	}
}
























chap05_referencedatatype-master\src\sec01_array\EX09_ReadArrayData_2D\ReadArrayData_2D.java"
package sec01_array.EX09_ReadArrayData_2D;

/*2차원 배열의 원소값 출력*/

public class ReadArrayData_2D {
	public static void main(String[] args) {
		//#1. 2차원 데이터의 배열의 길이
		int[][] array1 = new int[2][3];
		System.out.println(array1.length); //2
		System.out.println(array1[0].length); //3 첫번째 행이 가리키는 1차원 배열의 개수
		System.out.println(array1[1].length); //3 두번째 행이 가리키는 1차원 배열의 개수
		System.out.println();

		int[][] array2 = new int[][] {{1,2},{3,4,5}};
		System.out.println(array2.length); //2
		System.out.println(array2[0].length); //2 첫번째 행이 가리키는 1차원 배열의 개수
		System.out.println(array2[1].length); //3 두번째 행이 가리키는 1차원 배열의 개수
		System.out.println();

		//#2. 2차원 배열의 출력 방법
		System.out.print(array2[0][0]+" ");
		System.out.print(array2[0][1]+" ");
		System.out.println();
		System.out.print(array2[1][0]+" ");
		System.out.print(array2[1][1]+" ");
		System.out.println(array2[1][2]);
		System.out.println();

		for(int i=0; i<array2.length; i++) {
			for(int j=0; j<array2[i].length; j++) {
				System.out.print(array2[i][j]+" "); //1,2,3,4,5
			}
			System.out.println();
		}
		System.out.println();

		//for(하나의 원소를 꺼냈을때 저장할 변수:집합객체)
		for(int[] array: array2) {
			for(int k:array) {
				System.out.print(k+" ");
			}
			System.out.println();
		}
	}
}
















chap05_referencedatatype-master\src\sec01_array\EX10_ArgumentOfMainMethod\ArgumentOfMainMethod.java"
package sec01_array.EX10_ArgumentOfMainMethod;

/*main 메서드로의 매개변수 전달*/

public class ArgumentOfMainMethod {
	public static void main(String[] args) {
		//#1. args 배열의 길이 구하기
		System.out.println(args.length);
		System.out.println();

		//#2. 매개변수 출력 1
		for(int i=0; i<args.length; i++) {
			System.out.println(args[i]);
		}
		//System.out.println(Integer.parseInt(args[1])+1); //4??? 31
		System.out.println();

		//#3. 매개변수 출력 2
		for(String s : args) {
			System.out.println(s);
		}
		System.out.println();
	}
}

chap05_referencedatatype-master\src\sec02_string\EX01_CreateStringObject\CreateStringObject.java"
package sec02_string.EX01_CreateStringObject;

/*String 객체 생성의 두 가지 방법*/

public class CreateStringObject {
	public static void main(String[] args) {

		//#1. String 객체 생성 1
		String str1 = new String("안녕");
		System.out.println(str1);

		//#2. String 객체 생성 2
		String str2 = "안녕하세요";
		System.out.println(str2);
	}
}

chap05_referencedatatype-master\src\sec02_string\EX02_ModificationOfStringData\ModificationOfStringData.java"
package sec02_string.EX02_ModificationOfStringData;

/*String 객체의 문자열 수정 및 다른 참조자료형과의 비교*/

import java.util.Arrays;

public class ModificationOfStringData {
	public static void main(String[] args) {
		//#1. 문자열 수정 (객체내의 내용변경 불가 --> 새로운 객체 생성)
		String str1 = new String("안녕");
		String str2 = str1;

		str1="안녕하세요";

		System.out.println(str1); //안녕하세요
		System.out.println(str2); //안녕

		//@배열 참조자료형
		int[] array1 = new int[] {3,4,5};
		int[] array2 = array1;
		array1[0]=6;
		array1[1]=7;
		array1[2]=8;

		System.out.println(Arrays.toString(array1)); //[6, 7, 8]
		System.out.println(Arrays.toString(array2)); //[6, 7, 8]
	}
}

chap05_referencedatatype-master\src\sec02_string\EX03_SharingStringObject\SharingStringObject.java"
package sec02_string.EX03_SharingStringObject;

/*문자열 리터럴에 의한 생성 문자열 객체의 공유*/

public class SharingStringObject {
	public static void main(String[] args) {
		//#1. 문자열 객체 공유 (리터럴로 객체를 생성한 경우) new 키워드로 객체 생성한 경우 (별도의 객체 생성) 공유X
		String str1 = new String("안녕");
		String str2 = "안녕";
		String str3 = "안녕";
		String str4 = new String("안녕");

		//@stack 메모리 값 비고 (==)
		System.out.println(str1==str2); //false
		System.out.println(str2==str3); //true
		System.out.println(str3==str4); //false
		System.out.println(str4==str1); //false
	}
}

chap05_referencedatatype-master\src\sec02_string\EX04_PlusOperationOfString\PlusOperationOfString.java"
package sec02_string.EX04_PlusOperationOfString;

/*문자열의 ‘+’ 연산자(plus operation)*/

public class PlusOperationOfString {
	public static void main(String[] args) {
		//#1. 문자열 + 문자열
		String str1 = "안녕"+ "하세요"+ "!";
		System.out.println(str1); //안녕하세요!

		String str2 = "반갑";
		str2+="습니다";
		str2+="!";
		System.out.println(str2); //반갑습니다!
		System.out.println();

		//#2. 문자열 + 기본자료형 // 기본자료형 + 문자열
		String str3 = "안녕"+1; //안녕1;
		String str4 = "안녕"+String.valueOf(1); //안녕1
		String str5 = "안녕"+"1"; //안녕1

		System.out.println(str3);//안녕1
		System.out.println(str4);//안녕1
		System.out.println(str5);//안녕1
		System.out.println();

		//#3. 문자열과 기본자료형 혼용
		System.out.println(1+"안녕"); //1안녕
		System.out.println(1+"안녕"+2); //1안녕2
		System.out.println("안녕"+1+2); //안녕12
		System.out.println(1+2+"안녕"); //3안녕
	}
}



















chap05_referencedatatype-master\src\sec02_string\EX05_MethodsOfString_1\MethodsOfString_1.java"
package sec02_string.EX05_MethodsOfString_1;

/*String 클래스의 주요 메서드1*/

import java.util.Arrays;

public class MethodsOfString_1 {
	public static void main(String[] args) {
		//#1. 문자열길이 (length())
		String str1 = "Hello Java!";
		String str2 = "안녕하세요! 반갑습니다.";
		System.out.println(str1.length()); //11
		System.out.println(str2.length()); //13
		System.out.println();

		//#2. 문자열 검색 (charAt(), indexOf(), lastIndexOf())
		//@charAt()
		System.out.println(str1.charAt(1)); //e
		System.out.println(str2.charAt(1)); //녕
		System.out.println();

		//@indexOf(), lastIndexOf()
		System.out.println(str1.indexOf('a')); //7
		System.out.println(str1.lastIndexOf('a')); //9
		System.out.println(str1.indexOf('a', 8)); //9
		System.out.println(str1.lastIndexOf('a', 8)); //7
		System.out.println(str1.indexOf("Java")); //6
		System.out.println(str1.lastIndexOf("Java")); //6
		System.out.println(str2.indexOf("하세요")); //2
		System.out.println(str2.lastIndexOf("하세요")); //2
		System.out.println(str1.indexOf("Bye")); //-1
		System.out.println(str2.lastIndexOf("고맙습니다.")); //-1
		System.out.println();

		//#3. 문자열 변환 및 연결 (String.valueOf(), concat())
		//@String.valueOf(기본자료형) 기본자료형->String
		String str3 = String.valueOf(2.3);
		String str4 = String.valueOf(false);
		System.out.println(str3);
		System.out.println(str4);

		//@concat()
		String str5 = str3.concat(str4);
		System.out.println(str5);

		//String.valueOf() + concat() => +
		String str6 = "안녕" + 3; //안녕3
		String str7 = "안녕".concat(String.valueOf(3)); //안녕3


		//#4. 문자열 ->byte[] (getBytes()) , 문자열 -> char[] (toCharArray())
		String str8 = "Hello Java!";
		String str9 = "안녕하세요";

		//@ getBytes() 문자열 ->byte[]
		byte[] array1 = str8.getBytes();
		byte[] array2 = str9.getBytes();
		System.out.println(Arrays.toString(array1));
		System.out.println(Arrays.toString(array2));

		//@ toCharArray() 문자열 -> char[]
		char[] array3 = str8.toCharArray();
		char[] array4 = str9.toCharArray();
		System.out.println(Arrays.toString(array3));
		System.out.println(Arrays.toString(array4));
	}
}
















chap05_referencedatatype-master\src\sec02_string\EX06_MethodsOfString_2\MethodsOfString_2.java"
package sec02_string.EX06_MethodsOfString_2;

/*String 클래스의 주요 메서드2*/

import java.util.Arrays;

public class MethodsOfString_2 {
	public static void main(String[] args) {
		//#5. 문자열 수정
		//@toLowerCase(), toUpperCase()
		String str1 = "Java Study";
		System.out.println(str1.toLowerCase()); //java study
		System.out.println(str1.toUpperCase()); //JAVA STUDY

		//@ replace(,)
		System.out.println(str1.replace("Study", "공부")); //

		//@ substring(.)
		System.out.println(str1.substring(0,5)); //Java

		//@ split()
		String[] strArray = "abc/def-ghi jkl".split("/|-| ");
		System.out.println(Arrays.toString(strArray)); //[abc, def, ghi, jkl]

		//@ trim()
		System.out.println("   abc   ".trim());

		System.out.println();

		//#6. 문자열의 내용 비교 (equals(), equalsIgnoreCase())
		String str2 = new String("Java");
		String str3 = new String("Java");
		String str4 = new String("java");

		//@ stack 메모리 비교 (==)
		System.out.println(str2 == str3); //false
		System.out.println(str3 == str4); //false
		System.out.println(str4 == str2); //false

		//@ equals(), equalsIgnoreCase() : 내용비교
		System.out.println(str2.equals(str3)); //true
		System.out.println(str3.equals(str4)); //false
		System.out.println(str3.equalsIgnoreCase(str4)); //true
	}
}




















chap07_internalcomponents-master\src\sec02_method\EX01_ExternalCallMethods\ExternalCallMethods.java"
package sec02_method.EX01_ExternalCallMethods;

/*클래스의 외부에서 메서드 호출*/

//#1. 클래스의 정의
class A {
	//@1. 리턴타입: void + 매개변수: 없음
	void print() {
		System.out.println("안녕");
	}
	//@2. 리턴타입: int + 매개변수: 없음
	int data() {
		return 3;
	}
	//@3. 리턴타입: double + 매개변수: 2개
	double sum(int a, double b) {
		return a+b;
	}
	//@4. 리턴타입: void + 내부에 리턴 포함 (함수를 종료한다는 의미)
	void printMonth(int m) {
		if(m<0 || m>12) {
			System.out.println("잘못된 입력");
			return;
		}
		System.out.println(m+"월입니다.");
	}
}
public class ExternalCallMethods {
	public static void main(String[] args) {
		//#2. 객체생성
		A a = new A();

		//#3. 메서드 호출 (멤버활용)
		a.print();					//안녕
		int k = a.data();
		a.data();
		System.out.println(k);		//3
		double result = a.sum(3, 5.2);
		System.out.println(result);	//8.2
		a.printMonth(5); 			//5월입니다.
		a.printMonth(15); 			//잘못된 입력
	}
}

chap07_internalcomponents-master\src\sec02_method\EX02_InternalCallMethods\InternalCallMethods.java"
package sec02_method.EX02_InternalCallMethods;

/*클래스 내부에서의 메서드 호출*/

public class InternalCallMethods {
	public static void main(String[] args) {
		//같은 클래스 안에 있는 내부 메서드 호출
		print();

		int a = twice(3);
		System.out.println(a); //6

		double b = sum(a, 5.8);
		System.out.println(b); //11.8
	}
	public static void print() {
		System.out.println("안녕");
	}
	public static int twice(int k) {
		return k*2;
	}
	public static double sum(int m, double n) {
		return m+n;
	}
}

chap07_internalcomponents-master\src\sec02_method\EX03_ArrayArgumentMethod\ArrayArgumentMethod.java"
package sec02_method.EX03_ArrayArgumentMethod;

/*배열 매개변수를 가지는 메서드 호출*/

import java.util.Arrays;

public class ArrayArgumentMethod {
	public static void main(String[] args) {
		//배열을 매개변수로 가지는 메서드 호출
		int[] a = new int[] {1,2,3};
		printArray(a);
		printArray(new int[] {1,2,3});
		//printArray({1,2,3}); //오류
	}
	public static void printArray(int[] a) {
		System.out.println(Arrays.toString(a));
	}
}

chap07_internalcomponents-master\src\sec02_method\EX04_EffectOfPrimaryDataArgument\EffectOfPrimaryDataArgument.java"
package sec02_method.EX04_EffectOfPrimaryDataArgument;

/*기본자료형 매개개변수 값의 변화*/

public class EffectOfPrimaryDataArgument {
	public static void main(String[] args) {
		int a = 3;
		int result1 = twice(3);
		System.out.println(result1); //6
		int result2 = twice(a);
		System.out.println(result2); //6
		System.out.println(a); //3
	}
	public static int twice(int a) {
		a=a*2;
		return a;
	}
}

chap07_internalcomponents-master\src\sec02_method\EX05_EffectOfReferenceDataArgument\EffectOfReferenceDataArgument.java"
package sec02_method.EX05_EffectOfReferenceDataArgument;

/*참조자료형 매개개변수 값의 변화*/

import java.util.Arrays;

public class EffectOfReferenceDataArgument {
	public static void main(String[] args) {
		int[] array = new int[] {1,2,3};
		modifyData(array);
		printArray(array); //[4, 5, 6]
	}
	public static void modifyData(int[] a) {
		a[0]=4;
		a[1]=5;
		a[2]=6;
	}
	public static void printArray(int[] a) {
		System.out.println(Arrays.toString(a));
	}
}

chap07_internalcomponents-master\src\sec02_method\EX06_MethodOverloading\MethodOverloading.java"
package sec02_method.EX06_MethodOverloading;

/*메서드의 오버로딩(Overloading)*/

public class MethodOverloading {
	public static void main(String[] args) {
		print(); //데이터가 없습니다.
		print(3); //3
		print(5.8); //5.8
		print(2, 5);
	}
	public static void print() {
		System.out.println("데이터가 없습니다.");
	}
	public static void print(int a) {
		System.out.println(a);
	}
	public static void print(double a) {
		System.out.println(a);
	}
	/* 불가능 (void print(double a) {}와 중복)
	public static void print(double b) { //불가능
		System.out.println(b);
	}
	*/
	public static void print(int a, int b) {
		System.out.println("a: "+ a + " b: "+b);
	}
	/* 불가능 (void print(int a, int b){}와 중복)
	public static int print(int a, int b) { //불가능
		System.out.println("a: "+ a + " b: "+b);
		return a+b;
	}
	*/
}









chap07_internalcomponents-master\src\sec02_method\EX07_FlexibleSizeArrayArgument\FlexibleSizeArrayArgument.java"
package sec02_method.EX07_FlexibleSizeArrayArgument;

/*메서드의 가변길이 배열 매개변수*/

public class FlexibleSizeArrayArgument {
	public static void main(String[] args) {
		//#1. method1(int...values)
		method1(1,2);
		method1(1,2,3);
		method1();

		//#2. method2(String...values)
		method2("안녕", "방가");
		method2("땡큐", "베리", "감사");
		method2();
	}
	public static void method1(int...values) { //가변길이 배열
		System.out.println("배열의 길이: " + values.length);
		/* 배열 출력 방법 1
		for(int i=0; i<values.length; i++) {
			System.out.print(values[i]+" ");
		} */
		// 배열 출력 방법 2
		for(int k: values) {
			System.out.print(k+" ");
		}
		/* 배열 출력 방법 3
		//System.out.println(Arrays.toString(values));
		 */
		System.out.println();
	}
	public static void method2(String...values) { //가변길이 배열
		System.out.println("배열의 길이: " + values.length);
		/* 배열 출력 방법 1
		for(int i=0; i<values.length; i++) {
			System.out.print(values[i]+" ");
		} */
		// 배열 출력 방법 2
		for(String k: values) {
			System.out.print(k+" ");
		}
		/* 배열 출력 방법 3
		//System.out.println(Arrays.toString(values));
		 */
		System.out.println();
	}
}

chap07_internalcomponents-master\src\sec03_consturctor\EX01_DefaultConstructor\DefaultConstructor.java"
package sec03_consturctor.EX01_DefaultConstructor;

/*기본 생성자의 자동 추가*/

class A {
	int m;
	void work() {
		System.out.println(m); //0
	}
	//컴파일러가 자동으로 추가해주는 기본 생성자
	/*
	A(){
		//객체 생성 이후에 해야 할 추가 일들
	}
	*/
}
class B {
	int m;
	void work() {
		System.out.println(m); //0
	}
	B() { //기본생성자

	}
}
class C {
	int m;
	void work() {
		System.out.println(m); //생성자로 넘어온 값
	}
	C(int a) { //생성자의 기본기능 : 객체 생성 + 필드 초기화
		m=a;
	}
}
public class DefaultConstructor {
	public static void main(String[] args) {
		//#1. 클래스의 객체 생성
		A a = new A();
		B b = new B();
		//C c = new C(); //불가능
		C c = new C(3);

		//#2. 메서드 호출
		a.work(); //0
		b.work(); //0
		c.work(); //3
	}
}

























chap07_internalcomponents-master\src\sec03_consturctor\EX02_ConstructorOverloading\ConstructorOverloading.java"
package sec03_consturctor.EX02_ConstructorOverloading;

/*다양한 생성자를 사용한 다양한 객체 생성 방법*/

class A {
	A() {
		System.out.println("첫번째 생성자");
	}
	A(int a) {
		System.out.println("두번째 생성자");
	}
	A(int a, int b) {
		System.out.println("세번째 생성자");
	}
}
public class ConstructorOverloading {
	public static void main(String[] args) {
		//#1. 세가지 생성자를 이용한 객체 생성
		A a1 = new A(); //첫번째 생성자
		A a2 = new A(3); //두번째 생성자
		A a3 = new A(3, 5); //세번째 생성자
	}
}

chap07_internalcomponents-master\src\sec04_thiskeyword\EX01_ThisKeyword_1\ThisKeyword_1.java"
package sec04_thiskeyword.EX01_ThisKeyword_1;

/*묵시적 this 키워드 자동 추가 */

//#1. 클래스내부에서 필드, 메서드에 앞에 붙는 자동으로 붙는 this 키워드
class A {
	int m;
	int n;
	void init(int a, int b) {
		int c;
		c=3;
		this.m=a; //this. 생략시 자동 추가
		this.n=b; //this. 생략시 자동 추가
	}
	void work() {
		this.init(2,3); //this. 생략시 자동 추가
	}
}
public class ThisKeyword_1 {
	public static void main(String[] args) {
		//#2. 클래스 객체 생성
		A a = new A();
		//#3. 메서드 호출 / 필드값 활용
		a.work();
		System.out.println(a.m); //2
		System.out.println(a.n); //3
	}
}

chap07_internalcomponents-master\src\sec04_thiskeyword\EX02_ThisKeyword_2\ThisKeyword_2.java"
package sec04_thiskeyword.EX02_ThisKeyword_2;

/*명시적 this 키워드 추가 */

class A {
	int m;
	int n;
	void init(int m, int n) {
		m=m;
		n=n;
	}
}
class B {
	int m;
	int n;
	void init(int m, int n) {
		this.m=m;
		this.n=n;
	}
}
public class ThisKeyword_2 {
	public static void main(String[] args) {
		//#1. 필드명과 지역변수 명이 같은 경우 (this 키워드를 사용하지 않은 경우)
		A a = new A();
		a.init(2,3);
		System.out.println(a.m); //0
		System.out.println(a.n); //0

		//#2. 필드명과 지역변수 명이 같은 경우 (this 키워드를 직접 사용하는 경우)
		B b = new B();
		b.init(2,3);
		System.out.println(b.m); //2
		System.out.println(b.n); //3
	}
}









chap07_internalcomponents-master\src\sec05_thismethod\EX01_ThisMethod_1\ThisMethod_1.java"
package sec05_thismethod.EX01_ThisMethod_1;

/*this(생성자의 매개변수) 메서드의 문법적 특징과 의미*/

//#1. 클래스의 정의
class A {
	A() {
		System.out.println("첫번째 생성자");
	}
	A(int a){
		this(); //생성자의 첫줄에만 올 수 있다.
		System.out.println("두번째 생성자");
	}
	/* 메서드에서는 this() 메서드 사용 불가
	void abc() {
		this(); //불가능
	}
    */
}
public class ThisMethod_1 {
	public static void main(String[] args) {
		//#2. 객체 생성
		A a1 = new A(); //첫번째 생성자
		System.out.println();
		A a2 = new A(3);// 첫번째 생성자 -> 두번째 생성자
	}
}

chap07_internalcomponents-master\src\sec05_thismethod\EX02_ThisMethod_2\ThisMethod_2.java"
package sec05_thismethod.EX02_ThisMethod_2;

/*this(생성자 매개변수) 활용*/

class A {
	int m1, m2, m3, m4;
	A() {
		m1 = 1;
		m2 = 2;
		m3 = 3;
		m4 = 4;
	}
	A(int a) {
		m1 = a;
		m2 = 2;
		m3 = 3;
		m4 = 4;
	}
	A(int a, int b) {
		m1 = a;
		m2 = b;
		m3 = 3;
		m4 = 4;
	}
	void print() {
		System.out.print(m1+" ");
		System.out.print(m2+" ");
		System.out.print(m3+" ");
		System.out.print(m4);
		System.out.println();
	}
}
class B {
	int m1, m2, m3, m4;
	B() {
		m1 = 1;
		m2 = 2;
		m3 = 3;
		m4 = 4;
	}
	B(int a) {
		this();
		m1 = a;
	}
	B(int a, int b) {
		this(a);
		m2 = b;
	}
	/* 첫번째 생성자 호출 + 두개의 코드 추가
	B(int a, int b) {
		this();
		m1 = a;
		m2 = b;
	}
	*/
	void print() {
		System.out.print(m1+" ");
		System.out.print(m2+" ");
		System.out.print(m3+" ");
		System.out.print(m4);
		System.out.println();
	}
}
public class ThisMethod_2 {
	public static void main(String[] args) {
		//#1. 세가지 객체 생성 (this() 미사용)
		A a1 = new A();
		A a2 = new A(10);
		A a3 = new A(10,20);
		a1.print();
		a2.print();
		a3.print();

		System.out.println();

		//#2. 세가지 객체 생성 (this() 사용)
		B b1 = new B();
		B b2 = new B(10);
		B b3 = new B(10,20);
		b1.print();
		b2.print();
		b3.print();
	}
}


















chap08_externalcomponents-master\src\sec01_packageimport\common\A.java"
package sec01_packageimport.common;

public class A {
	public int m=3;
	public int n=4;

	public void print() {
		System.out.println("임포트");
	}
}

chap08_externalcomponents-master\src\sec02_externalclass\EX01_ExternalClass_1\ExternalClass_1.java"
package sec02_externalclass.EX01_ExternalClass_1;

/*하나의 소스파일에 외부 클래스 구성*/

class A{
	int m=3;
	int n=4;
	void print() {
		System.out.println(m+", "+n);
	}
}
public class ExternalClass_1 {
	public static void main(String[] args) {
		A a = new A();
		a.print(); //3, 4
	}
}

chap08_externalcomponents-master\src\sec02_externalclass\EX02_ExternalClass_2\pack1\A.java"
package sec02_externalclass.EX02_ExternalClass_2.pack1;

/*외부클래스를 별도의 파일로 분리*/

public class A {
	int m=3;
	int n=4;

	public void print() {
		System.out.println(m+", "+n);
	}
}

chap08_externalcomponents-master\src\sec02_externalclass\EX02_ExternalClass_2\pack2\ExternalClass_2.java"
package sec02_externalclass.EX02_ExternalClass_2.pack2;

import sec02_externalclass.EX02_ExternalClass_2.pack1.A;

/*외부클래스를 별도의 파일로 분리*/

public class ExternalClass_2 {
	public static void main(String[] args) {
		A a = new A();
		a.print(); //3, 4
	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX01_AccessModifierOfMember\pack1\B.java"
package sec01_accessmodifier.EX01_AccessModifierOfMember.pack1;

/*멤버 및 생성자에 적용되는 네 가지 접근 지정자*/

public class B {
	public void print() { //a, b, c, d
		//#객체생성
		A a = new A(); //객체생성 가능

		//#멤버 활용
		System.out.print(a.a+ " "); //가능
		System.out.print(a.b+ " "); //가능
		System.out.print(a.c+ " "); //가능
		//System.out.print(a.d); //불가능
		System.out.println();
	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX01_AccessModifierOfMember\pack2\C.java"
package sec01_accessmodifier.EX01_AccessModifierOfMember.pack2;

/*멤버 및 생성자에 적용되는 네 가지 접근 지정자*/

import sec01_accessmodifier.EX01_AccessModifierOfMember.pack1.A;

public class C {
	public void print() { //a, b, c, d
		//#객체생성
		A a = new A(); //객체생성 가능

		//#멤버 활용
		System.out.print(a.a+ " "); //가능
		//System.out.print(a.b+ " "); //불가능
		//System.out.print(a.c+ " "); //불가능
		//System.out.print(a.d); //불가능
		System.out.println();
	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX02_AccessModifierOfClass_1\A.java"
package sec01_accessmodifier.EX02_AccessModifierOfClass_1;

/*같은 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//public class
public class A {
	//public 기본생성자를 컴파일러가 추가
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX02_AccessModifierOfClass_1\AccessModifierOfClass_1.java"
package sec01_accessmodifier.EX02_AccessModifierOfClass_1;

/*같은 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

public class AccessModifierOfClass_1 {
	public static void main(String[] args) {
		//#1. 객체 생성
		A a = new A(); //선언가능(A a) + 생성자 호출 가능(new A())
		B b = new B(); //선언가능(B b) + 생성자 호출 가능(new B())
		C c = new C(); //선언가능(C c) + 생성자 호출 가능(new C())
	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX02_AccessModifierOfClass_1\B.java"
package sec01_accessmodifier.EX02_AccessModifierOfClass_1;

/*같은 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//default class
class B {
	//default 생성자 자동 추가
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX02_AccessModifierOfClass_1\C.java"
package sec01_accessmodifier.EX02_AccessModifierOfClass_1;

/*같은 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//public class
public class C {
	C(){ //default 생성자

	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX03_AccessModifierOfClass_2\AccessModifierOfClass_2.java"
package sec01_accessmodifier.EX03_AccessModifierOfClass_2;

/*다른 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

import sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack.AA;
//import sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack.BB; //불가능
import sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack.CC;

public class AccessModifierOfClass_2 {
	public static void main(String[] args) {
		//#1. 객체 생성
		AA a = new AA(); //객체생성가능(A a) + 생성자 호출 가능(new AA())
		//BB b = new BB(); //객체생성불가능(BB b)
		//CC c = new CC(); //객체생성가능(CC c) + 생성자 호출 불가능(new CC())
	}
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX03_AccessModifierOfClass_2\pack\AA.java"
package sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack;

/*다른 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//public class
public class AA {
	//public 기본생성자를 컴파일러가 추가
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX03_AccessModifierOfClass_2\pack\BB.java"
package sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack;

/*다른 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//default class
class BB {
	//default 생성자 자동 추가
}

chap09_modifier_1-master\src\sec01_accessmodifier\EX03_AccessModifierOfClass_2\pack\CC.java"
package sec01_accessmodifier.EX03_AccessModifierOfClass_2.pack;

/*다른 패키지에서의 클래스 접근지정자 vs. 생성자 접근지정자*/

//public class
public class CC {
	CC(){ //default 생성자

	}
}

chap09_modifier_1-master\src\sec02_staticmodifier\EX01_StaticField_1\StaticField_1.java"
package sec02_staticmodifier.EX01_StaticField_1;

/*인스턴스 필드와 정적필드의 활용 방법*/

class A{
	int m=3; //인스턴스 필드
	static int n=5; //정적(static) 필드
}
public class StaticField_1 {
	public static void main(String[] args) {
		//#1. 인스턴스 필드 활용방법 (항상 객체생성을 한 후 사용가능)
		A a1 = new A();
		System.out.println(a1.m); //3

		//#2. 정적(static) 필드 활용 방법
		//@방법#1 (객체생성없이 클래스 이름으로 바로 활용)
		System.out.println(A.n); //5
		//@방법#2 (객체생성 후 활용 : 인스턴스와 동일) : 가능한 지양
		A a2 = new A();
		System.out.println(a2.n); //5
	}
}

chap09_modifier_1-master\src\sec02_staticmodifier\EX02_StaticField_2\StaticField_2.java"
package sec02_staticmodifier.EX02_StaticField_2;

/*정적필드의 공유기능*/

class A {
	int m=3; //인스턴스 필드
	static int n=5; //정적(static) 필드
}
public class StaticField_2 {
	public static void main(String[] args) {
		A a1 = new A();
		A a2 = new A();

		//인스턴스 필드
		a1.m=5;
		a2.m=6;
		System.out.println(a1.m); //5
		System.out.println(a2.m); //6

		//정적필드
		a1.n=7;
		a2.n=8;
		System.out.println(a1.n); //8
		System.out.println(a2.n); //8

		A.n=9;
		System.out.println(a1.n); //9
		System.out.println(a2.n); //9
	}
}








chap09_modifier_1-master\src\sec02_staticmodifier\EX03_StaticMethod\StaticMethod.java"
package sec02_staticmodifier.EX03_StaticMethod;

/*인스턴스 메서드와 정적 메서드*/

class A {
	void abc() { //인스턴스 메서드
		System.out.println("instance 메서드");
	}
	static void bcd() { //정적메서드
		System.out.println("static 메서드");
	}
}
public class StaticMethod {
	public static void main(String[] args) {
		//#1. 인스턴스 메서드 활용방법 (객체생성 후에만 사용가능)
		A a1 = new A();
		a1.abc(); //instance 메서드

		//#2. 정적 메서드 활용방법
		//@방법1. 클래스 이름으로 바로 접근하여 사용
		A.bcd(); //static 메서드
		//@방법2. 객체생성후에도 사용가능 : 가능한 지양
		A a2 = new A();
		a2.bcd(); //static 메서드
	}
}

chap09_modifier_1-master\src\sec02_staticmodifier\EX04_StaticInitialBlock\StaticInitialBlock.java"
package sec02_staticmodifier.EX04_StaticInitialBlock;

/*정적 초기화 블록*/

class A{
	int a;
	static int b;
	static {
		b=5; // static 필드의 초기화는 static {} 내에서 수행
		System.out.println("클래스 A가 로딩되었습니다!!");
	}
	A() {
		a=3; // 인스턴스 필드 초기화는 생성자에서 일반적으로 수행
		//b=5;
	}
}
public class StaticInitialBlock {
	public static void main(String[] args) {
		System.out.println(A.b); //5
	}
}


chap10_inheritancepolymorphism-master\src\sec02_typecasting\EX01_Typecasting_1\Typecasting_1.java"
package sec02_typecasting.EX01_Typecasting_1;

/*클래스의 업캐스팅 및 다운캐스팅*/

//# 클래스의 상속관계
class A {}
class B extends A{}
class C extends B{}
class D extends B{}

public class Typecasting_1 {
	public static void main(String[] args) {
		//#1. 업캐스팅 (자동변환): 생략시 컴파일러가 자동 추가
		A ac = (A)new C(); // C->A 업캐스팅 (자동변환)
		B bc = (B)new C(); // C->B 업캐스팅 (자동변환)

		B bb = new B();
		A a = (A)bb; //B->A 업캐스팅 (자동변환)

		//#2-1. 다운캐스팅 (수동변환) : 캐스팅이 불가능한 경우 (실행시 예외발생)
		A aa = new A();
//		B b = (B)aa; //A->B 다운캐스팅 (수동변환)
//		C c = (C)aa; //A->C 다운캐스팅 (수동변환)

		//#2-2. 다운캐스팅 (수동변환) : 캐스팅이 가능한 경우
		A ab = new B();
		B b = (B)ab; //A->B 다운캐스팅 (수동변환)
//		C c = (C)ab; //A->C 다운캐스팅 (수동변환) : 불가능

		B bd = new D();
		D d = (D)bd; //B->D 다운캐스팅 (수동변환)

		A ad = new D();
		B b1 = (B)ad; //A->B 다운캐스팅 (수동변환)
		D d1 = (D)ad; //A->D 다운캐스팅 (수동변환)
	}
}

chap10_inheritancepolymorphism-master\src\sec02_typecasting\EX02_Typecasting_2\Typecasting_2.java"
package sec02_typecasting.EX02_Typecasting_2;

/*선언타입에 따른 사용가능한 멤버*/

class A {
	int m=3;
	void abc() {
		System.out.println("A 클래스");
	}
}
class B extends A {
	int n=4;
	void bcd() {
		System.out.println("B 클래스");
	}
}
public class Typecasting_2 {
	public static void main(String[] args) {
		//#1. A 타입   / A 생성자
		A aa = new A();
		System.out.println(aa.m);
		aa.abc();

		//#2. B 타입 / B 생성자
		B bb = new B();
		System.out.println(bb.m);
		System.out.println(bb.n);
		bb.abc();
		bb.bcd();

		//#3. A 타입 / B 생성자 : 다형적 표현
		A ab = new B();
		System.out.println(ab.m);
		ab.abc();
	}
}



















chap10_inheritancepolymorphism-master\src\sec02_typecasting\EX03_Typecasting_3\Typecasting_3.java"
package sec02_typecasting.EX03_Typecasting_3;

/*캐스팅의 가능여부를 확인할 수 있는 instanceof*/

class A{}
class B extends A{}

public class Typecasting_3 {
	public static void main(String[] args) {
		//#1. instanceof
		A aa = new A();
		A ab = new B();

		System.out.println(aa instanceof A); //true
		System.out.println(ab instanceof A); //true

		System.out.println(aa instanceof B); //false
		System.out.println(ab instanceof B); //true

		if(aa instanceof B) {
			B b = (B)aa;
			System.out.println("aa를 B로 캐스팅하였습니다.");
		} else {
			System.out.println("aa는 B 타입으로 캐스팅이 불가!!!");
		}
		if(ab instanceof B) {
			B b = (B)ab;
			System.out.println("ab를 B로 캐스팅하였습니다.");
		} else {
			System.out.println("ab는 B 타입으로 캐스팅이 불가!!!");
		}
		if ("안녕" instanceof String) {
			System.out.println("\"안녕\"은 String 클래스입니다");
		}
	}
}










chap10_inheritancepolymorphism-master\src\sec03_methodoverriding\EX01_MethodOverriding_1\MethodOverriding_1.java"
package sec03_methodoverriding.EX01_MethodOverriding_1;

/*메서드 오버라이딩의 기본 동작*/

class A{
	void print() {
		System.out.println("A 클래스");
	}
}
class B extends A{
	@Override
	void print() {
		System.out.println("B 클래스");
	}
}
public class MethodOverriding_1 {
	public static void main(String[] args) {
		//#1. A 타입 / A 생성자
		A aa = new A();
		aa.print(); //A 클래스

		//#2. B 타입 / B 생성자
		B bb = new B();
		bb.print(); //B 클래스

		//#3. A 타입 / B 생성자
		A ab = new B();
		ab.print(); //B 클래스
	}
}

chap10_inheritancepolymorphism-master\src\sec03_methodoverriding\EX02_MethodOverriding_2\MethodOverriding_2.java"
package sec03_methodoverriding.EX02_MethodOverriding_2;

/*메서드 오버라이딩의 대표적 예시*/

class Animal {
	void cry() {}
}
class Bird extends Animal {
	@Override
	void cry() {
		System.out.println("짹짹");
	}
}
class Cat extends Animal {
	@Override
	void cry() {
		System.out.println("야옹");
	}
}
class Dog extends Animal {
	@Override
	void cry() {
		System.out.println("멍멍");
	}
}

public class MethodOverriding_2 {
	public static void main(String[] args) {
		//#1. 각각의 타입으로 선언 + 각각의 타입으로 생성
		Animal aa = new Animal();
		Bird bb = new Bird();
		Cat cc = new Cat();
		Dog dd = new Dog();
		aa.cry();
		bb.cry();
		cc.cry();
		dd.cry();
		System.out.println();

		//#2. Animal 타입으로 선언 + 자식클래스 타입으로 생성
		Animal ab = new Bird();
		Animal ac = new Cat();
		Animal ad = new Dog();
		ab.cry();
		ac.cry();
		ad.cry();
		System.out.println();

		//#3. 배열로 관리
		Animal[] animals = {ab, ac, ad};
		for(Animal animal : animals) {
			animal.cry();
		}
	}
}






























chap10_inheritancepolymorphism-master\src\sec03_methodoverriding\EX03_MethodOverriding_3\MethodOverriding_3.java"
package sec03_methodoverriding.EX03_MethodOverriding_3;

/*메서드 오버라이딩 vs. 메서드 오버로딩*/

class A {
	void print1() {
		System.out.println("A 클래스 print1");
	}
	void print2() {
		System.out.println("A 클래스 print2");
	}
}
class B extends A {
	@Override
	void print1() {
		System.out.println("B 클래스 print1");
	}
	void print2(int a) {
		System.out.println("B 클래스 print2");
	}
}
public class MethodOverriding_3 {
	public static void main(String[] args) {
		//#1. A 타입 선언 / A 생성자 사용
		A aa = new A();
		aa.print1(); //A 클래스 print1
		aa.print2(); //A 클래스 print2
		System.out.println();

		//#2. B 타입 선언 / B 생성자 사용
		B bb = new B();
		bb.print1(); // B 클래스 print1
		bb.print2(); // A 클래스 print2
		bb.print2(3);// B 클래스 print2
		System.out.println();

		//#3. A 타입 선언 / B 생성자 사용
		A ab = new B();
		ab.print1(); //B 클래스 print1
		ab.print2(); //A 클래스 print2
	}
}



























chap10_inheritancepolymorphism-master\src\sec03_methodoverriding\EX04_MethodOverriding_4\MethodOverriding_4.java"
package sec03_methodoverriding.EX04_MethodOverriding_4;

/*메서드 오버라이딩과 접근지정자*/

class A {
	protected void abc() {}
}

class B1 extends A {
	public void abc() {}
}
class B2 extends A {
	protected void abc() {}
}
class B3 extends A {
	//void abc() {} //default 접근지정자 (좁아져서 불가능)
}
class B4 extends A {
	//private void abc() {} //private 접근지정자 (좁아져서 불가능)
}

public class MethodOverriding_4 {
	public static void main(String[] args) {

	}
}

chap10_inheritancepolymorphism-master\src\sec04_overlapmember\EX01_OverlapInstanceField\OverlapInstanceField.java"
package sec04_overlapmember.EX01_OverlapInstanceField;

/*인스턴스 필드의 중복*/

class A {
	int m = 3;
}
class B extends A {
	int m = 4;
}
public class OverlapInstanceField {
	public static void main(String[] args) {
		//#1. 객체생성
		A aa = new A();
		B bb = new B();
		A ab = new B();

		//#2. 인스턴스 필드
		System.out.println(aa.m); //3
		System.out.println(bb.m); //4
		System.out.println(ab.m); //3
	}
}


chap10_inheritancepolymorphism-master\src\sec04_overlapmember\EX02_OverlapStaticField\OverlapStaticField.java"
package sec04_overlapmember.EX02_OverlapStaticField;

/*정적 필드의 중복*/

class A {
	static int m = 3;
}
class B extends A {
	static int m = 4;
}
public class OverlapStaticField {
	public static void main(String[] args) {
		//#1.클래스 이름으로 바로 접근
		System.out.println(A.m); //3
		System.out.println(B.m); //4
		System.out.println();

		//#2.객체 생성
		A aa = new A();
		B bb = new B();
		A ab = new B();

		//#3. 객체 생성을 통한 static field
		System.out.println(aa.m); //3
		System.out.println(bb.m); //4
		System.out.println(ab.m); //3
	}
}

chap10_inheritancepolymorphism-master\src\sec04_overlapmember\EX03_OverlapStaticMethod\OverlapStaticMethod.java"
package sec04_overlapmember.EX03_OverlapStaticMethod;

/*정적 메서드의 중복*/

class A{
	static void print() {
		System.out.println("A 클래스");
	}
}
class B extends A{
	static void print() {
		System.out.println("B 클래스");
	}
}
public class OverlapStaticMethod {
	public static void main(String[] args) {
		//#1. 클래스 이름으로 바로 접근
		A.print(); //A 클래스
		B.print(); //B 클래스
		System.out.println();

		//#2. 객체 생성
		A aa = new A();
		B bb = new B();
		A ab = new B();

		//#3. 객체를 통한 메서드 호출
		aa.print(); //A 클래스
		bb.print(); //B 클래스
		ab.print(); //A 클래스
	}
}

chap10_inheritancepolymorphism-master\src\sec05_superkeywordsupermethod\EX01_SuperKeyword_1\SuperKeyword_1.java"
package sec05_superkeywordsupermethod.EX01_SuperKeyword_1;

/*멤버 앞에 참조변수를 생략(this.)하는 경우의 메서드 호출*/

class A {
	void abc() {
		System.out.println("A 클래스의 abc()");
	}
}
class B extends A{
	void abc() {
		System.out.println("B 클래스의 abc()");
	}
	void bcd() {
		abc(); //this.abc();
	}
}
public class SuperKeyword_1 {
	public static void main(String[] args) {
		//#1. 객체 생성
		B bb = new B();

		//#2. 메서드 호출
		bb.bcd(); //B 클래스의 abc()
	}
}

chap10_inheritancepolymorphism-master\src\sec05_superkeywordsupermethod\EX02_SuperKeyword_2\SuperKeyword_2.java"
package sec05_superkeywordsupermethod.EX02_SuperKeyword_2;

/*멤버앞에 super 키워드를 사용한 경우의 메서드 호출*/

class A {
	void abc() {
		System.out.println("A 클래스의 abc()");
	}
}
class B extends A{
	void abc() {
		System.out.println("B 클래스의 abc()");
	}
	void bcd() {
		super.abc(); //super.abc() : 부모클래스 객체의 abc() 메서드 호출;
	}
}
public class SuperKeyword_2 {
	public static void main(String[] args) {
		//#1. 객체 생성
		B bb = new B();

		//#2. 메서드 호출
		bb.bcd(); //A 클래스의 abc()
	}
}

chap10_inheritancepolymorphism-master\src\sec05_superkeywordsupermethod\EX03_SuperMethod_1\SuperMethod_1.java"
package sec05_superkeywordsupermethod.EX03_SuperMethod_1;

/*super() 메서드의 기능 및 컴파일러에 의한 자동추가 super()*/

class A{
	A(){
		System.out.println("A 생성자");
	}
}
class B extends A{
	B(){
		super(); //생략시 컴파일러가 자동 추가 (부모클래스의 생성자 호출)
		System.out.println("B 생성자");
	}
}
class C {
	C(int a){
		System.out.println("C 생성자");
	}
}
class D extends C {
	/* 컴파일러가 자동으로 추가해주는 내용
	D(){
		super();
	}
	*/
	D(){
		super(3);
	}
}

public class SuperMethod_1 {
	public static void main(String[] args) {
		//#1. A 객체 생성
		A aa = new A();
		System.out.println(); // A 생성자

		//#2. B 객체 생성
		B bb = new B(); // A 생성자 -> B 생성자
	}
}

chap10_inheritancepolymorphism-master\src\sec05_superkeywordsupermethod\EX04_SuperMethod_2\SuperMethod_2.java"
package sec05_superkeywordsupermethod.EX04_SuperMethod_2;

/*this()메서드와 super() 메서드의 혼용*/

class A{
	A(){
		this(3);
		System.out.println("A 생성자 1");
	}
	A(int a){
		System.out.println("A 생성자 2");
	}
}
class B extends A{
	B(){
		this(3);
		System.out.println("B 생성자 1");
	}
	B(int a){
		System.out.println("B 생성자 2");
	}
}
public class SuperMethod_2 {
	public static void main(String[] args) {
		//#1. A 객체 생성
		A aa1 = new A(); //A 생성자 2 A 생성자 1
		System.out.println();
		A aa2 = new A(3); //A 생성자 2
		System.out.println();

		//#2. B 객체 생성
		B bb1 = new B(); //A 생성자 2 A 생성자 1 B 생성자 2 B 생성자 1
		System.out.println();
		B bb2 = new B(3);//A 생성자 2 A 생성자 1 B 생성자 2
	}
}























chap10_inheritancepolymorphism-master\src\sec06_objectclass\EX01_ObjectMethod_toString\ObjectMethod_toString.java"
package sec06_objectclass.EX01_ObjectMethod_toString;

/*Object 클래스의 toString() 메서드*/

class A { //extends Object (컴파일러에 의해서 자동추가)
	int a=3;
	int b=4;
}
class B {
	int a=3;
	int b=4;

	public String toString() {
		return "필드값(a, b) =" + a +" " +b;
	}
}
public class ObjectMethod_toString {
	public static void main(String[] args) {
		//#1. 객체 생성
		A a = new A();
		B b = new B();

		//#2. 메서드 호출
		System.out.printf("%x\n", a.hashCode()); //hashcode를 16진수로 표현
		System.out.println(a.toString()); //toString()메서드는 생략시 자동 추가
		System.out.println(b);
	}
}

chap10_inheritancepolymorphism-master\src\sec06_objectclass\EX02_ObjectMethod_equals\ObjectMethod_equals.java"
package sec06_objectclass.EX02_ObjectMethod_equals;

/*Object 클래스의 equals(.) 메서드*/

class A{
	String name;
	A(String name){
		this.name = name;
	}
}
class B{
	String name;
	B(String name){
		this.name = name;
	}
	@Override
	public boolean equals(Object obj) {
		if(this.name == ((B)obj).name) {
			return true;
		} else
			return false;
	}
}
public class ObjectMethod_equals {
	public static void main(String[] args) {
		A a1 = new A("안녕");
		A a2 = new A("안녕");

		System.out.println(a1==a2); //false
		System.out.println(a1.equals(a2));//false


		B b1 = new B("안녕");
		B b2 = new B("안녕");

		System.out.println(b1==b2); //false
		System.out.println(b1.equals(b2));//true
	}
}




















chap10_inheritancepolymorphism-master\src\sec06_objectclass\EX03_ObjectMethod_hashcode\ObjectMethod_hashcode.java"
package sec06_objectclass.EX03_ObjectMethod_hashcode;

/*Object 클래스의 hashCode() 메서드*/

import java.util.HashMap;

class A {
	String name;
	A(String name){
		this.name = name;
	}
	@Override
	public boolean equals(Object obj) {
		if(this.name == ((A)obj).name) {
			return true;
		} else
			return false;
	}
	@Override
	public String toString() {
		return name;
	}
}
class B {
	String name;
	B(String name){
		this.name = name;
	}
	@Override
	public boolean equals(Object obj) {
		if(this.name == ((B)obj).name) {
			return true;
		} else
			return false;
	}
	@Override
	public int hashCode() {
		return name.hashCode();
	}
	@Override
	public String toString() {
		return name;
	}
}
public class ObjectMethod_hashcode {
	public static void main(String[] args) {
		HashMap<Integer, String> hm1 = new HashMap<>();
		hm1.put(1, "데이터1");
		hm1.put(1, "데이터2");
		hm1.put(2, "데이터3");
		System.out.println(hm1);

		HashMap<A, String> hm2 = new HashMap<>();
		hm2.put(new A("첫번째"), "데이터1");
		hm2.put(new A("첫번째"), "데이터2");
		hm2.put(new A("두번째"), "데이터3");
		System.out.println(hm2);

		HashMap<B, String> hm3 = new HashMap<>();
		hm3.put(new B("첫번째"), "데이터1");
		hm3.put(new B("첫번째"), "데이터2");
		hm3.put(new B("두번째"), "데이터3");
		System.out.println(hm3);
	}
}
























chap11_modifier_2-master\src\sec02_abstractmodifier\EX01_AbstractModifier_1\AbstractModifier_1.java"
package sec02_abstractmodifier.EX01_AbstractModifier_1;

/*일반클래스를 상속하여 오버라이딩 수행*/

class Animal {
	void cry() {}
}
class Cat extends Animal {
	void cry() {
		System.out.println("야옹");
	}
}
class Dog extends Animal {
	void cry() {
		System.out.println("멍멍");
	}
}
public class AbstractModifier_1 {
	public static void main(String[] args) {
		//#1. 객체생성
		Animal animal1 = new Cat();
		Animal animal2 = new Dog();

		//#2. 메서드 호출
		animal1.cry(); //야옹
		animal2.cry(); //멍멍
	}
}

chap11_modifier_2-master\src\sec02_abstractmodifier\EX02_AbstractModifier_2\AbstractModifier_2.java"
package sec02_abstractmodifier.EX02_AbstractModifier_2;

/*추상클래스를 상속하여 오버라이딩 수행*/

abstract class Animal {
	abstract void cry();
}
class Cat extends Animal {
	void cry() {
		System.out.println("야옹");
	}
}
class Dog extends Animal {
	void cry() {
		System.out.println("멍멍");
	}
}

public class AbstractModifier_2 {
	public static void main(String[] args) {
		//#1. 객체생성
		Animal animal1 = new Cat();
		Animal animal2 = new Dog();

		//#2. 메서드 호출
		animal1.cry(); //야옹
		animal2.cry(); //멍멍
	}
}


chap12_abstractclassinterface-master\src\sec02_interface\EX01_InterfaceCharacteristics\InterfaceCharacteristics.java"
﻿package sec02_interface.EX01_InterfaceCharacteristics;

/*인터페이스내 필드 및 메서드의 제어자*/

interface A {
	public static final int a = 3;
	public abstract void abc();
}
interface B {
	int b = 3; //생략시 자동으로 public static final
	void bcd();//생략시 자동으로 public abstract
}
public class InterfaceCharacteristics {
	public static void main(String[] args) {
		//#1. static 자동추가 체크
		System.out.println(A.a);
		System.out.println(B.b);

		//#2. final 자동추가 체크
		//A.a = 5; //불가능
		//B.b = 5; //불가능
	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX02_InheritanceOfInterface_1\InheritanceOfInterface_1.java"
package sec02_interface.EX02_InheritanceOfInterface_1;

/*인터페이스와 클래스의 상속 키워드 */

interface A {}
interface B {}

//#1. 단일인터페이스 상속
class C implements A {
}
//#2. 다중인터페이스 상속
class D implements A, B {
}
//#3. 클래스와 인터페이스를 한번에 상속 (extends와 implements의 순서는 변경 불가)
class E extends C implements A,B {

}
public class InheritanceOfInterface_1 {
	public static void main(String[] args) {

	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX03_InheritanceOfInterface_2\InheritanceOfInterface_2.java"
package sec02_interface.EX03_InheritanceOfInterface_2;

/*인터페이스 상속 자식클래스의 접근지정자*/

interface A {
	public abstract void abc();
}
interface B {
	void bcd(); //생략시 public abstract
}
class C implements A {
	public void abc() {
		//...
	}
}
/* public -> default 불가능
class D implements B {
	void bcd() {

	}
}
*/
public class InheritanceOfInterface_2 {
	public static void main(String[] args) {

	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX04_CreateObjectOfInterface_1\CreateObjectOfInterface_1.java"
package sec02_interface.EX04_CreateObjectOfInterface_1;

/*자식클래스의 직접 정의를 통한 인터페이스타입의 객체 생성 (방법#1)*/

interface A {
	int a = 3;
	void abc();
}
class B implements A {
	public void abc() {
		System.out.println("방법#1. 자식클래스 생성자로 객체 생성");
	}
}
public class CreateObjectOfInterface_1 {
	public static void main(String[] args) {
		//#1. 객체 생성
		A b1 = new B();
		A b2 = new B();

		//#2. 메서드 호출
		b1.abc();
		b2.abc();
	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX05_CreateObjectOfInterface_2\CreateObjectOfInterface_2.java"
package sec02_interface.EX05_CreateObjectOfInterface_2;

/*익명이너클래스를 활용한 인터페이스타입의 객체 생성 (방법#2)*/

interface A {
	int a = 3;
	void abc();
}
public class CreateObjectOfInterface_2 {
	public static void main(String[] args) {
		//#1. 객체 생성
		A a1 = new A() {
			public void abc() {
				System.out.println("방법2. 익명이너클래스를 이용한 객체 생성 ");
			}
		};
		A a2 = new A() {
			public void abc() {
				System.out.println("방법2. 익명이너클래스를 이용한 객체 생성 ");
			}
		};
		//#2. 메서드 호출
		a1.abc();
		a2.abc();
	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX06_DefaultMethod_1\DefaultMethod_1.java"
package sec02_interface.EX06_DefaultMethod_1;

/*인터페이스 구현 및 디폴트메서드의 오버라이딩*/

interface A {
	void abc(); //2020년 생성
	default void bcd() {
		System.out.println("A 인터페이스의 bcd()");
	} //2030년 생성
}
class B implements A { //2020년 생성
	public void abc() {
		System.out.println("B 클래스의 abc()");
	}
}
class C implements A {
	public void abc() {
		System.out.println("C 클래스의 abc()");
	}
	public void bcd() {
		System.out.println("C 클래스의 bcd()");
	}
}
public class DefaultMethod_1 {
	public static void main(String[] args) {
		//#1. 객체 생성
		A a1 = new B();
		A a2 = new C();

		//#2. 메서드 호출
		a1.abc(); //B 클래스의 abc()
		a1.bcd(); //A 인터페이스의 bcd()

		a2.abc(); //C 클래스의 abc()
		a2.bcd(); //C 클래스의 bcd()
	}
}




























chap12_abstractclassinterface-master\src\sec02_interface\EX07_DefaultMethod_2\DefaultMethod_2.java"
package sec02_interface.EX07_DefaultMethod_2;

/*자식클래스에서 부모인터페이스의 디폴트메서드 호출*/

interface A {
	default void abc() {
		System.out.println("A 인터페이스의 abc()");
	}
}
class B implements A {
	public void abc() {
		A.super.abc();	//super.abc() 이건 부모클래스의  abc() 메서드 호출하란 소리
		System.out.println("B 클래스의 abc()");
	}
}
public class DefaultMethod_2 {
	public static void main(String[] args) {
		//#1. 객체생성
		B b = new B();

		//#2. 메서드 호출
		b.abc(); //A 인터페이스의 abc() B 클래스의 abc()
	}
}

chap12_abstractclassinterface-master\src\sec02_interface\EX08_StaticMethod\StaticMethod.java"
package sec02_interface.EX08_StaticMethod;

/*인터페이스내의 정적(staic) 메서드*/

interface A {
	static void abc() {
		System.out.println("A 인터페이스의 정적 메서드 abc()");
	}
}
public class StaticMethod {
	public static void main(String[] args) {
		//#1.정적메서드 호출
		A.abc();
	}
}

chap13_innerclassandinnerinterface-master\src\sec02_staticinnerclass\EX01_CreateObjectAndAccessMember\CreateObjectAndAccessMember.java"
package sec02_staticinnerclass.EX01_CreateObjectAndAccessMember;

/*정적이너클래스에서의 외부멤버 사용 및 객체 생성*/

class A {
	int a = 3;
	static int b = 4;
	void method1() {
		System.out.println("instance method");
	}
	static void method2() {
		System.out.println("static method");
	}
	//static inner class
	static class B {
		void bcd() {
			//#1.필드 사용
			//System.out.println(a); //static은 static만 포함 가능
			System.out.println(b);
			//#2.메서드 호출
			//method1();//static은 static만 포함 가능
			method2();
		}
	}
}
public class CreateObjectAndAccessMember {
	public static void main(String[] args) {
		//#1. static inner class의 객체 생성
		A.B b = new A.B();
		//#2. 메서드 호출
		b.bcd();
	}
}





























chap13_innerclassandinnerinterface-master\src\sec03_localinnerclass\EX01_AccessMemberAndLocalVariable\AccessMemberAndLocalVariable.java"
package sec03_localinnerclass.EX01_AccessMemberAndLocalVariable;

/*지역이너클래스 내부에서 외부 멤버 및 메서드 지역변수 활용*/

class A {
	int a = 3; //필드
	void abc() {
		int b = 5; //지역변수
		//지역이너클래스
		class B {
			void bcd() {
				System.out.println(a); //필드
				System.out.println(b); //지역변수
				a=5;
				//b=7; //지역이너클래스에서 사용하는 지역변수는 자동으로 final로 선언
			}
		}
		B bb = new B();
		bb.bcd();
	}
}
public class AccessMemberAndLocalVariable {
	public static void main(String[] args) {
		//#1. 객체 생성 및 메서드 호출
		A a = new A();
		a.abc();
	}
}

chap13_innerclassandinnerinterface-master\src\sec03_localinnerclass\EX02_GeneratedClassNames\GeneratedClassNames.java"
package sec03_localinnerclass.EX02_GeneratedClassNames;

/*지역이너클래스의 컴파일 이후 생성 클래스 파일*/

class A {
	void abc() {
		class B{}
		class C{}
	}
	void bcd() {
		class C{}
		class D{}
	}
}
public class GeneratedClassNames {
	public static void main(String[] args) {

	}
}

chap13_innerclassandinnerinterface-master\src\sec04_anonymousclass\EX01_AnonymousClass_1\AnonymousClass_1.java"
package sec04_anonymousclass.EX01_AnonymousClass_1;

/*인터페이스를 상속한 이너클래스를 생성하여 인터페이스 객체 생성*/

class A {
	C c = new B();
	void abc() {
		c.bcd();
	}
	class B implements C {
		public void bcd() {
			System.out.println("인스턴스 이너클래스");
		}
	}
}
interface C {
	public abstract void bcd();
}
public class AnonymousClass_1 {
	public static void main(String[] args) {
		//#1. 객체 생성 및 메서드 호출
		A a = new A();
		a.abc(); //인스턴스 이너클래스
	}
}

chap13_innerclassandinnerinterface-master\src\sec04_anonymousclass\EX02_AnonymousClass_2\AnonymousClass_2.java"
package sec04_anonymousclass.EX02_AnonymousClass_2;

/*익명이너클래스를 활용하여 인터페이스 객체 생성*/

class A {
	C c = new C() {
		public void bcd() {
			System.out.println("익명이너클래스");
		}
	};
	void abc() {
		c.bcd();
	}
}
interface C {
	public abstract void bcd();
}
public class AnonymousClass_2 {
	public static void main(String[] args) {
		//#1. 객체 생성 및 메서드 호출
		A a = new A();
		a.abc(); //익명이너클래스
	}
}

chap13_innerclassandinnerinterface-master\src\sec04_anonymousclass\EX03_AnonymousClass_3\AnonymousClass_3.java"
package sec04_anonymousclass.EX03_AnonymousClass_3;

/*클래스 정의 및 참조변수명을 사용/미사용의 경우 매개변수 객체 전달*/

interface A {
	public abstract void abc();
}
//#1. 자식클래스를 직접 생성
class B implements A {
	public void abc() {
		System.out.println("매개변수 전달");
	}
}
class C {
	void cde(A a) {
		a.abc();
	}
}
public class AnonymousClass_3 {
	public static void main(String[] args) {
		C c = new C();
		//#1. 방법#1 클래스명 O + 참조변수명  O
		A a = new B();
		c.cde(a); //매개변수 전달
		//#2. 방법#2 클래스명 O + 참조변수명  X
		c.cde(new B()); //매개변수 전달
	}
}

chap13_innerclassandinnerinterface-master\src\sec04_anonymousclass\EX04_AnonymousClass_4\AnonymousClass_4.java"
package sec04_anonymousclass.EX04_AnonymousClass_4;

/*클래스 미정의 및 참조변수명을 사용/미사용의 경우 매개변수 객체 전달*/

interface A {
	public abstract void abc();
}
class C {
	void cde(A a) {
		a.abc();
	}
}
public class AnonymousClass_4 {
	public static void main(String[] args) {
		C c = new C();
		//#3. 방법#3 클래스명 X + 참조변수명  O
		A a = new A() {
			public void abc() {
				System.out.println("매개변수 전달");
			}
		};
		c.cde(a); //매개변수 전달
		//#4. 방법#4 클래스명 X + 참조변수명  X
		c.cde(new A() {
			public void abc() {
				System.out.println("매개변수 전달");
			}
		}); //매개변수 전달
	}
}

chap13_innerclassandinnerinterface-master\src\sec05_innerinterface\EX01_CreateObjectOfInnerInterface\CreateObjectOfInnerInterface.java"
package sec05_innerinterface.EX01_CreateObjectOfInnerInterface;

/*이너인터페이스의 두 가지 객체 생성 방법*/

class A {
	interface B {
		public abstract void bcd();
	}
}
class C implements A.B {
	public void bcd() {
		System.out.println("이너인터페이스 구현 클래스 생성");
	}
}
public class CreateObjectOfInnerInterface {
	public static void main(String[] args) {
		//객체생성 방법 #1 (자식클래스 직접 생성)
		A.B ab = new C();
		C c = new C();
		c.bcd();

		//객체생성 방법 #2 (익명이너클래스 생성)
		A.B b = new A.B() {
			public void bcd() {
				System.out.println("익명이너클래스로 객체 생성");
			}
		};
		b.bcd();
	}
}

chap13_innerclassandinnerinterface-master\src\sec05_innerinterface\EX02_ButtonAPIExample\ButtonAPIExample.java"
package sec05_innerinterface.EX02_ButtonAPIExample;

/*일반적인 UI API의 구조 예시 (버튼)*/

class Button {
	OnClickListener ocl;
	void setOnClickListener (OnClickListener ocl) {
		this.ocl = ocl;
	}
	interface OnClickListener {
		public abstract void onClick();
	}
	void onClick () {
		ocl.onClick();
	}
}
public class ButtonAPIExample {
	public static void main(String[] args) {
		//#1. 개발자 1. 클릭했을때 음악재생
		Button btn1 = new Button();
		btn1.setOnClickListener(new Button.OnClickListener() {
			@Override
			public void onClick() {
				System.out.println("개발자1 : 음악재생");
			}
		});
		btn1.onClick(); //개발자1 : 음악재생

		//#2. 개발자 2. 클릭했을때 네이버 접속
		Button btn2 = new Button();
		btn2.setOnClickListener(new Button.OnClickListener() {
			@Override
			public void onClick() {
				System.out.println("개발자2 : 네이버접속");
			}
		});
		btn2.onClick(); //개발자2 : 네이버접속
	}
}






























chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX01_TryCatchFinally\TryCatchFinally.java"
package sec02_exceptionhandlingsyntax.EX01_TryCatchFinally;

public class TryCatchFinally {
	public static void main(String[] args) {

		//#1. try-catch
		try {
			System.out.println(3/0); //실행예외 (ArithmeticException)
			System.out.println("프로그램 종료");
		}
		catch(ArithmeticException e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
			System.out.println("프로그램 종료");
		}

		//#2. try-catch-finally
		try {
			System.out.println(3/0); //실행예외 (ArithmeticException)
		}
		catch(ArithmeticException e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}
	}
}

chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX02_MultiCatch_1\MultiCatch_1.java"
package sec02_exceptionhandlingsyntax.EX02_MultiCatch_1;

public class MultiCatch_1 {
	public static void main(String[] args) {

		//#1. 단일 try-catch
		try {
			System.out.println(3/0); //실행예외 (ArithmeticException)
		}
		catch(ArithmeticException e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}

		try {
			int num = Integer.parseInt("10A"); //실행예외 (NumberFormatException)
		}
		catch(NumberFormatException e) {
			System.out.println("숫자로 바꿀 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}
		System.out.println();

		//#2. 다중 try-catch
		try {
			System.out.println(3/0);
			int num = Integer.parseInt("10A");
		}
		catch(ArithmeticException e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
		}
		catch(NumberFormatException e) {
			System.out.println("숫자로 바꿀 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}
	}
}


























chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX03_MultiCatch_2\MultiCatch_2.java"
package sec02_exceptionhandlingsyntax.EX03_MultiCatch_2;

public class MultiCatch_2 {
	public static void main(String[] args) {

		//#1. catch 블록의 순서가 잘못된 경우
		/*
		try {
			System.out.println(3/1);
			int num = Integer.parseInt("10A");
		}
		catch(Exception e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
		}
		catch(NumberFormatException e) {
			System.out.println("숫자로 바꿀 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}
		*/

		//#2. catch 블록의 올바른 순서
		try {
			System.out.println(3/1);
			int num = Integer.parseInt("10A");
		}
		catch(NumberFormatException e) {
			System.out.println("숫자로 바꿀 수 없습니다.");
		}
		catch(Exception e) {
			System.out.println("숫자는 0으로 나눌 수 없습니다.");
		}
		finally {
			System.out.println("프로그램 종료");
		}

	}
}

chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX04_MultiCatch_3\MultiCatch_3.java"
package sec02_exceptionhandlingsyntax.EX04_MultiCatch_3;

public class MultiCatch_3 {
	public static void main(String[] args) {

		//#1. catch블록을 각각 처리한 경우
		try {
			System.out.println(3/1);
			int num = Integer.parseInt("10A");
		}
		catch(ArithmeticException e) {
			System.out.println("예외가 발생했습니다.");
		}
		catch(NumberFormatException e) {
			System.out.println("예외가 발생했습니다.");
		}


		//#2. catch 블록을 하나로 통합한 경우
		try {
			System.out.println(3/1);
			int num = Integer.parseInt("10A");
		}
		catch(ArithmeticException | NumberFormatException e) {
			System.out.println("예외가 발생했습니다.");
		}

	}
}

chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX05_TryWithResouce_1\TryWithResouce_1.java"
﻿package sec02_exceptionhandlingsyntax.EX05_TryWithResouce_1;

import java.io.IOException;
import java.io.InputStreamReader;

public class TryWithResouce_1 {
	public static void main(String[] args) {

		System.out.println("문자를 입력하세요!");

		//참고. System.in 리소스를 해제하면 더이상 콘솔입력이 불가
		//#1. 자동리소스 해제
		try(InputStreamReader isr1 = new InputStreamReader(System.in);){
			char input = (char)isr1.read();
			System.out.println("입력글자  = " + input);
		}
		catch(IOException e) {
			e.printStackTrace();
		}

		//#2. 수동리소스 해제
		InputStreamReader isr2=null;
		try{
			isr2 = new InputStreamReader(System.in);
			char input = (char)isr2.read();
			System.out.println("입력글자  = " + input);
		}
		catch(IOException e) {
			e.printStackTrace();
		}
		finally {
			//리소스 해제 구문
			if(isr2!=null) {
				try { //리소스 해제
					isr2.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}

chap14_exceptionhandling-master\src\sec02_exceptionhandlingsyntax\EX06_TryWithResouce_2\TryWithResouce_2.java"
package sec02_exceptionhandlingsyntax.EX06_TryWithResouce_2;

class A implements AutoCloseable {
	String resource;
	A(String resouce){
		this.resource = resouce;
	}
	@Override
	public void close() throws Exception {
		if(resource!=null) {
			resource=null;
			System.out.println("리소스가 해제되었습니다.");
		}
	}
}

public class TryWithResouce_2 {
	public static void main(String[] args) {

		//#1. 리소스를 사용하고 finally에서 리소스 수동 해제하기
		A a1 = null;
		try {
			a1 = new A("특정파일");
		} catch (Exception e) {
			System.out.println("예외처리");
		} finally {
			//리소스 수동 해제
			if(a1.resource!=null) {
				try {
					a1.close();
				} catch (Exception e) {}
			}
		}

		//#2. 자동 리소스 해제
		try (A a2 = new A("특정파일");) {

		} catch (Exception e) {
			System.out.println("예외처리");
		}
	}
}

chap14_exceptionhandling-master\src\sec03_throwsexception\EX01_ThrowsException_1\ThrowsException_1.java"
package sec03_throwsexception.EX01_ThrowsException_1;

//#1. 하위메서드에 직접 예외를 처리하는 경우
class A {

	void abc() {
		bcd();
	}
	void bcd() {
		try {
			Thread.sleep(1000); //일반예외 : InterruptedException
		} catch (InterruptedException e) {
			//예외처리 구문
		}
	}
}

//#2. 예외를 호출 메서드로 전가하는 경우
class B {
	void abc() {
		try {
			bcd(); //일반예외 : InterruptedException
		} catch (InterruptedException e) {
			//예외처리 구문
		}
	}
	void bcd() throws InterruptedException {
		Thread.sleep(1000); //일반예외 : InterruptedException
	}
}


public class ThrowsException_1 {
	public static void main(String[] args) {

	}
}













chap14_exceptionhandling-master\src\sec03_throwsexception\EX02_ThrowsException_2\ThrowsException_2.java"
package sec03_throwsexception.EX02_ThrowsException_2;

public class ThrowsException_2 {
	public static void main(String[] args) throws ClassNotFoundException{
		Class cls = Class.forName("java.lang.Object2");
	}
}

chap14_exceptionhandling-master\src\sec03_throwsexception\EX03_ThrowsException_3\ThrowsException_3.java"
package sec03_throwsexception.EX03_ThrowsException_3;

//#1. 하위메서드에 직접 예외를 처리하는 경우
class A {

	void abc() {
		bcd();
	}
	void bcd() {
		try {
			Class cls = Class.forName("java.lang.Object"); //일반예외 : ClassNotFoundException
			Thread.sleep(1000); //일반예외 : InterruptedException
		} catch (InterruptedException | ClassNotFoundException e) {
			//예외처리 구문
		}
	}
}

//#2. 예외를 호출 메서드로 전가하는 경우
class B {
	void abc() {
		try {
			bcd(); //일반예외 : InterruptedException
		} catch (InterruptedException | ClassNotFoundException e) {
			//예외처리 구문
		}
	}
	void bcd() throws InterruptedException, ClassNotFoundException {
		Class cls = Class.forName("java.lang.Object"); //일반예외 : ClassNotFoundException
		Thread.sleep(1000); //일반예외 : InterruptedException
	}
}

public class ThrowsException_3 {
	public static void main(String[] args) {
	}
}

chap14_exceptionhandling-master\src\sec04_userexception\EX01_CreateUserException\CreateUserException.java"
package sec04_userexception.EX01_CreateUserException;

//#1. 사용자 일반예외 (checked exception)
class MyException extends Exception {
	public MyException() {
		super();
	}
	public MyException(String message) {
		super(message);
	}
}

//#2. 사용자 실행예외 (unchecked exception = runtime exception)
class MyRTException extends RuntimeException {
	public MyRTException() {
		super();
	}
	public MyRTException(String message) {
		super(message);
	}
}

class A {
	//#3. 사용자 정의 예외 객체 생성
	MyException me1 = new MyException();
	MyException me2 = new MyException("예외메세지: MyException");

	MyRTException mre1 = new MyRTException();
	MyRTException mre2 = new MyRTException("예외메세지: MyRTException");

	//#4. 예외 던지기 (throw) : 던진시점에서 예외 발생
	//@방법#1. 예외를 직접처리
	void abc_1(int num) {
		try {
			if(num>70)
				System.out.println("정상작동");
			else
				throw me1; //예외를 던진 이시점에 예외 발생
		} catch (MyException e) {
			System.out.println("예외처리 1");
		}
	}
	void bcd_1() {
		abc_1(65);
	}
	//@방법#2. 예외의 전가
	void abc_2(int num) throws MyException {
		if(num>70)
			System.out.println("정상작동");
		else
			throw me1; //예외를 던진 이시점에 예외 발생
	}

	void bcd_2() {
		try {
			abc_2(65);
		} catch (MyException e) {
			System.out.println("예외처리 2");
		}
	}
}

public class CreateUserException {
	public static void main(String[] args) {
		A a = new A();
		a.bcd_1();
		a.bcd_2();
	}
}























chap14_exceptionhandling-master\src\sec04_userexception\EX02_ExceptionMethod_1\ExceptionMethod_1.java"
package sec04_userexception.EX02_ExceptionMethod_1;

public class ExceptionMethod_1 {
	public static void main(String[] args) {

		//#1. 예외객체 생성시 메시지 전달하지 않는 경우
		try {
			throw new Exception(); //이 시점에서 예외 발생
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}

		//#2. 예외객체 생성시 메시지 전달하는 경우
		try {
			throw new Exception("예외메세지"); //이 시점에서 예외 발생
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}

	}
}

chap14_exceptionhandling-master\src\sec04_userexception\EX03_ExceptoinMethod_2\ExceptoinMethod_2.java"
package sec04_userexception.EX03_ExceptoinMethod_2;

class A {
	void abc() throws NumberFormatException {
		bcd();
	}
	void bcd() throws NumberFormatException {
		cde();
	}
	void cde() throws NumberFormatException {
		int num = Integer.parseInt("10A");
	}
}


public class ExceptoinMethod_2 {
	public static void main(String[] args) {
		//#1. 객체 생성
		A a = new A();
		//#2. 메서드 호출 / 예외처리
		try {
			a.abc();
		} catch (NumberFormatException e) {
			e.printStackTrace();
		}
	}
}
chap14_exceptionhandling-master\src\sec04_userexception\EX04_UserExceptionExample\UserExceptionExample.java"
package sec04_userexception.EX04_UserExceptionExample;

//#점수가 음수인 경우에 예외발생
class MinusException extends Exception {
	public MinusException() {
		super();
	}
	public MinusException(String message) {
		super(message);
	}
}
//#점수가 100점을 초과하는 경우에 예외 발생
class OverException extends Exception {
	public OverException() {
		super();
	}
	public OverException(String message) {
		super(message);
	}
}

class A {
	void checkScore(int score) throws MinusException, OverException {
		if(score<0) {
			throw new MinusException("예외발생 : 음수값입력");
		}
        else if (score>100)
			throw new OverException("예외발생 : 100점 초과");
        else
        	System.out.println("정상적인 값입니다.");
	}
}

public class UserExceptionExample {
	public static void main(String[] args) {

		A a = new A();
		try {
			a.checkScore(85);
			a.checkScore(150);
		} catch (MinusException | OverException e) {
			System.out.println(e.getMessage());
		}
	}
}



























chap15_thread-master\src\sec02_createandstartthread\EX01_CreateAndStartThread_M1C1\CreateAndStartThread_M1C1.java"
﻿package sec02_createandstartthread.EX01_CreateAndStartThread_M1C1;

//#1. 방법1(M1). Thread 클래스 상속하여 클래스 생성  case1: 2개의 쓰레드 생성

class SMIFileThread extends Thread {
	@Override
	public void run() {
		//#2. 자막 번호 하나~다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try { Thread.sleep(10);} catch (InterruptedException e) {}
		//#4. 자막번호 출력
		for (int i=0; i<strArray.length; i++) {
			System.out.println(" - (자막번호) "+strArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}

public class CreateAndStartThread_M1C1 {
	public static void main(String[] args) {

		//SMIFileThread 객체 생성 및 시작
		Thread smiFileThread = new SMIFileThread();
		smiFileThread.start();

		//#1 비디오프레임 1~5
		int[] intArray = {1, 2, 3, 4, 5};

		//#3. 비디오 프레임 출력
		for (int i=0; i<intArray.length; i++) {
			System.out.print("(비디오프레임) "+intArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}
chap15_thread-master\src\sec02_createandstartthread\EX02_CreateAndStartThread_M1C2\CreateAndStartThread_M1C2.java"
package sec02_createandstartthread.EX02_CreateAndStartThread_M1C2;

//#1. 방법1(M1). Thread 클래스 상속하여 클래스 생성  case2: 3개의 쓰레드 생성

class SMIFileThread extends Thread {
	@Override
	public void run() {
		//#2. 자막 번호 하나~다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try { Thread.sleep(10);} catch (InterruptedException e) {}
		//#4. 자막번호 출력
		for (int i=0; i<strArray.length; i++) {
			System.out.println(" - (자막번호) "+strArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}

class VideoFileThread extends Thread {
	@Override
	public void run() {
		//#1 비디오프레임 1~5
		int[] intArray = {1, 2, 3, 4, 5};

		//#3. 비디오 프레임 출력
		for (int i=0; i<intArray.length; i++) {
			System.out.print("(비디오프레임) "+intArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}

public class CreateAndStartThread_M1C2 {
	public static void main(String[] args) {

		//SMIFileThread 객체 생성 및 시작
		Thread smiFileThread = new SMIFileThread();
		smiFileThread.start();

		//VideoFileThread 객체 생성 및 시작
		Thread videoFileThread = new VideoFileThread();
		videoFileThread.start();

	}
}

chap15_thread-master\src\sec02_createandstartthread\EX03_CreateAndStartThread_M2C1\CreateAndStartThread_M2C1.java"
package sec02_createandstartthread.EX03_CreateAndStartThread_M2C1;

//#1. 방법2(M2). Runnable 인터페이스 상속하여 클래스 생성  case1: 2개의 쓰레드 생성

class SMIFileRunnable implements Runnable {

	@Override
	public void run() {
		//#2. 자막 번호 하나~다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try { Thread.sleep(10);} catch (InterruptedException e) {}
		//#4. 자막번호 출력
		for (int i=0; i<strArray.length; i++) {
			System.out.println(" - (자막번호) "+strArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}

public class CreateAndStartThread_M2C1 {
	public static void main(String[] args) {

		//SMIRunnable 객체 생성
		Runnable smiFileRunnable = new SMIFileRunnable();
		//smiFileRunnable.start(); //오류
		Thread thread = new Thread(smiFileRunnable);
		thread.start();

		//#1 비디오프레임 1~5
		int[] intArray = {1, 2, 3, 4, 5};

		//#3. 비디오 프레임 출력
		for (int i=0; i<intArray.length; i++) {
			System.out.print("(비디오프레임) "+intArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}

	}
}

chap15_thread-master\src\sec02_createandstartthread\EX04_CreateAndStartThread_M2C2\CreateAndStartThread_M2C2.java"
package sec02_createandstartthread.EX04_CreateAndStartThread_M2C2;

//#1. 방법2(M2). Runnable 인터페이스 상속하여 클래스 생성  case2: 3개의 쓰레드 생성

class SMIFileRunnable implements Runnable {

	@Override
	public void run() {
		//#2. 자막 번호 하나~다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try { Thread.sleep(10);} catch (InterruptedException e) {}
		//#4. 자막번호 출력
		for (int i=0; i<strArray.length; i++) {
			System.out.println(" - (자막번호) "+strArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}

}

class VideoFileRunnable implements Runnable {
	@Override
	public void run() {
		//#1 비디오프레임 1~5
		int[] intArray = {1, 2, 3, 4, 5};

		//#3. 비디오 프레임 출력
		for (int i=0; i<intArray.length; i++) {
			System.out.print("(비디오프레임) "+intArray[i]);
			try { Thread.sleep(200);} catch (InterruptedException e) {}
		}
	}
}


public class CreateAndStartThread_M2C2 {
	public static void main(String[] args) {

		//SMIRunnable 객체 생성
		Runnable smiFileRunnable = new SMIFileRunnable();
		//smiFileRunnable.start(); //오류
		Thread thread1 = new Thread(smiFileRunnable);
		thread1.start();

		//VideoFileRunnable 객체 생성
		Runnable videoFileRunnable = new VideoFileRunnable();
		//videoFileRunnable.start(); //오류
		Thread thread2 = new Thread(videoFileRunnable);
		thread2.start();
	}
}

chap15_thread-master\src\sec02_createandstartthread\EX05_CreateAndStartThread_M2C3\CreateAndStartThread_M2C3.java"
package sec02_createandstartthread.EX05_CreateAndStartThread_M2C3;

public class CreateAndStartThread_M2C3 {
	public static void main(String[] args) {

		//자막번호를 출력하는 쓰레드의 익명이너클래스 정의
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				//#2. 자막 번호 하나~다섯
				String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
				try { Thread.sleep(10);} catch (InterruptedException e) {}
				//#4. 자막번호 출력
				for (int i=0; i<strArray.length; i++) {
					System.out.println(" - (자막번호) "+strArray[i]);
					try { Thread.sleep(200);} catch (InterruptedException e) {}
				}
			}
		});

		//비디오 프레임 번호를 출력하는 쓰레드의 익명이너클래스 정의
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				//#1 비디오프레임 1~5
				int[] intArray = {1, 2, 3, 4, 5};

				//#3. 비디오 프레임 출력
				for (int i=0; i<intArray.length; i++) {
					System.out.print("(비디오프레임) "+intArray[i]);
					try { Thread.sleep(200);} catch (InterruptedException e) {}
				}
			}
		});

		//Thread 실행
		thread1.start();
		thread2.start();
	}
}

chap15_thread-master\src\sec03_threadproperties\EX01_ThreadProperties_1\ThreadProperties_1.java"
package sec03_threadproperties.EX01_ThreadProperties_1;

//쓰레드 객체 가져오기/ 이름설정/ 쓰레드 수

public class ThreadProperties_1 {
	public static void main(String[] args) {

		//#1. 객체가져오기 (currentThread()) / 쓰레드 수 (activeCount())
		Thread curThread = Thread.currentThread();
		System.out.println("현재 쓰레드의 이름 = " + curThread.getName());
		System.out.println("동작하는 쓰레스 수 = " + Thread.activeCount());

		//#2. 쓰레드 이름 지정 (자동지정)
		for(int i=0; i<3; i++) {
			Thread thread = new Thread();
			System.out.println(thread.getName());
			thread.start();
		}

		//#3. 쓰레드 이름 직접 지정
		for(int i=0; i<3; i++) {
			Thread thread = new Thread();
			thread.setName(i+"번째 쓰레드");
			System.out.println(thread.getName());
			thread.start();
		}

		//#4. 쓰레드 이름 지정 (자동지정)
		for(int i=0; i<3; i++) {
			Thread thread = new Thread();
			System.out.println(thread.getName());
			thread.start();
		}

		//#5. 쓰레드 수
		System.out.println("동작하는 쓰레스 수 = " + Thread.activeCount());
	}
}

chap15_thread-master\src\sec03_threadproperties\EX02_ThreadProperties_2\ThreadProperties_2.java"
package sec03_threadproperties.EX02_ThreadProperties_2;

//우선순위
class MyThread extends Thread {
	@Override
	public void run() {
		for(long i=0; i<1000000000 ; i++) { } //시간 지연용
		System.out.println(getName() + "  우선순위 : "+ getPriority());
	}
}

public class ThreadProperties_2 {
	public static void main(String[] args) {

		//#참고. CPU core
		System.out.println("코어수 : "+ Runtime.getRuntime().availableProcessors()); //

		//#1. 디폴트 우선순위
		for(int i=0; i<3; i++) {
			Thread thread = new MyThread();
			thread.start();
		}

		try { Thread.sleep(1000); } catch (InterruptedException e) {}

		//#2. 우선순위를 직접 지정
		for(int i=0; i<10; i++) {
			Thread thread = new MyThread();
			thread.setName(i+"번째 쓰레드");
			if(i==9) thread.setPriority(10);
			thread.start();
		}
	}
}

chap15_thread-master\src\sec03_threadproperties\EX03_ThreadProperties_3_1\ThreadProperties_3_1.java"
package sec03_threadproperties.EX03_ThreadProperties_3_1;

class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println(getName() + " : " + (isDaemon()? "데몬쓰레드":"일반쓰레드") );
		for(int i =0; i<6; i++) {
			System.out.println(getName() + " : " + i + "초");
			try{Thread.sleep(1000);}catch(InterruptedException e) {}
		}
	}
}

public class ThreadProperties_3_1 {
	public static void main(String[] args) {

		//# 일반쓰레드
		Thread thread1 = new MyThread();
		thread1.setDaemon(false);//디폴트
		thread1.setName("thread1");
		thread1.start();

		//# 3.5초 후 main Thread 종료
		try {Thread.sleep(3500);} catch (InterruptedException e) {}
		System.out.println("main Thread 종료");
	}
}










chap15_thread-master\src\sec03_threadproperties\EX04_ThreadProperties_3_2\ThreadProperties_3_2.java"
package sec03_threadproperties.EX04_ThreadProperties_3_2;

class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println(getName() + " : " + (isDaemon()? "데몬쓰레드":"일반쓰레드") );
		for(int i =0; i<6; i++) {
			System.out.println(getName() + " : " + i + "초");
			try{Thread.sleep(1000);}catch(InterruptedException e) {}
		}
	}
}

public class ThreadProperties_3_2 {
	public static void main(String[] args) {

		//# 데몬쓰레드
		Thread thread2 = new MyThread();
		thread2.setDaemon(true);//데몬쓰레드로 설정
		thread2.setName("thread2");
		thread2.start();

		//# 3.5초 후 main Thread 종료
		try {Thread.sleep(3500);} catch (InterruptedException e) {}
		System.out.println("main Thread 종료");
	}
}










chap15_thread-master\src\sec03_threadproperties\EX05_ThreadProperties_3_3\ThreadProperties_3_3.java"
package sec03_threadproperties.EX05_ThreadProperties_3_3;

class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println(getName() + " : " + (isDaemon()? "데몬쓰레드":"일반쓰레드") );
		for(int i =0; i<6; i++) {
			System.out.println(getName() + " : " + i + "초");
			try{Thread.sleep(1000);}catch(InterruptedException e) {}
		}
	}
}

public class ThreadProperties_3_3 {
	public static void main(String[] args) {

		//#1. 일반쓰레드
		Thread thread1 = new MyThread();
		thread1.setDaemon(false);// 일반쓰레드로 설정
		thread1.setName("thread1");
		thread1.start();

		//#2. 데몬쓰레드
		Thread thread2 = new MyThread();
		thread2.setDaemon(true);// 데몬쓰레드로 설정
		thread2.setName("thread2");
		thread2.start();

		//#3. 3.5초 후 main Thread 종료
		try {Thread.sleep(3500);} catch (InterruptedException e) {}
		System.out.println("main Thread 종료");
	}
}










chap15_thread-master\src\sec04_synchronizedmethodandblock\EX01_TheNeedsForSynchronized\TheNeedsForSynchronized.java"
package sec04_synchronizedmethodandblock.EX01_TheNeedsForSynchronized;

//# 공유객체
class MyData {
	int data = 3;

	public void plusData() {
		int mydata = data; //데이터를 가져오기
		try { Thread.sleep(2000);} catch (InterruptedException e) {}
		data = mydata+1;
	}
}

//#공유객체를 사용하는 쓰레드
class PlusThread extends Thread {
	MyData myData;
	public PlusThread(MyData myData) {
		this.myData=myData;
	}

	@Override
	public void run() {
		myData.plusData();
		System.out.println(getName() + "실행결과 : " + myData.data);
	}
}


public class TheNeedsForSynchronized {
	public static void main(String[] args) {
		//#공유객체 생성
		MyData myData = new MyData();

		//#1.  plusThread 1
		Thread plusThread1 = new PlusThread(myData);
		plusThread1.setName("plusThread1");
		plusThread1.start();

		try { Thread.sleep(1000);} catch (InterruptedException e) {}

		//#2.  plusThread 2
		Thread plusThread2 = new PlusThread(myData);
		plusThread2.setName("plusThread2");
		plusThread2.start();
	}
}






























chap15_thread-master\src\sec04_synchronizedmethodandblock\EX02_SynchronizedMethod\SynchronizedMethod.java"
package sec04_synchronizedmethodandblock.EX02_SynchronizedMethod;

//# 공유객체
class MyData {
	int data = 3;

	public synchronized void plusData() {
		int mydata = data; //데이터를 가져오기
		try { Thread.sleep(2000);} catch (InterruptedException e) {}
		data = mydata+1;
	}
}

//#공유객체를 사용하는 쓰레드
class PlusThread extends Thread {
	MyData myData;
	public PlusThread(MyData myData) {
		this.myData=myData;
	}

	@Override
	public void run() {
		myData.plusData();
		System.out.println(getName() + "실행결과 : " + myData.data);
	}
}

public class SynchronizedMethod {
	public static void main(String[] args) {
		//#공유객체 생성
		MyData myData = new MyData();

		//#1.  plusThread 1
		Thread plusThread1 = new PlusThread(myData);
		plusThread1.setName("plusThread1");
		plusThread1.start();

		try { Thread.sleep(1000);} catch (InterruptedException e) {}

		//#2.  plusThread 2
		Thread plusThread2 = new PlusThread(myData);
		plusThread2.setName("plusThread2");
		plusThread2.start();
	}
}

chap15_thread-master\src\sec04_synchronizedmethodandblock\EX03_SynchronizedBlock\SynchronizedBlock.java"
package sec04_synchronizedmethodandblock.EX03_SynchronizedBlock;

//# 공유객체
class MyData {
	int data = 3;

	public void plusData() {
		//....
		synchronized (this) {
			int mydata = data; //데이터를 가져오기
			try { Thread.sleep(2000);} catch (InterruptedException e) {}
			data = mydata+1;
		}
	}
}

//#공유객체를 사용하는 쓰레드
class PlusThread extends Thread {
	MyData myData;
	public PlusThread(MyData myData) {
		this.myData=myData;
	}

	@Override
	public void run() {
		myData.plusData();
		System.out.println(getName() + "실행결과 : " + myData.data);
	}
}

public class SynchronizedBlock {
	public static void main(String[] args) {
		//#공유객체 생성
		MyData myData = new MyData();

		//#1.  plusThread 1
		Thread plusThread1 = new PlusThread(myData);
		plusThread1.setName("plusThread1");
		plusThread1.start();

		try { Thread.sleep(1000);} catch (InterruptedException e) {}

		//#2.  plusThread 2
		Thread plusThread2 = new PlusThread(myData);
		plusThread2.setName("plusThread2");
		plusThread2.start();
	}
}

chap15_thread-master\src\sec04_synchronizedmethodandblock\EX04_KeyObject_1\KeyObject_1.java"
package sec04_synchronizedmethodandblock.EX04_KeyObject_1;

class MyData {
	synchronized void abc() {
		for(int i=0; i<3; i++) {
			System.out.println(i + "sec");
			try { Thread.sleep(1000); } catch (InterruptedException e) {}
		}
	}

	synchronized void bcd() {
		for(int i=0; i<3; i++) {
			System.out.println(i + "초");
			try { Thread.sleep(1000); } catch (InterruptedException e) {}
		}
	}

	void cde() {
		synchronized(this) {
			for(int i=0; i<3; i++) {
				System.out.println(i + "번째");
				try { Thread.sleep(1000); } catch (InterruptedException e) {}
			}
		}
	}
}

public class KeyObject_1 {
	public static void main(String[] args) {
		//#공유객체
		MyData myData = new MyData();

		//#세개의 쓰레드가 각각의 메서드 호출
		new Thread() {
			public void run() {
				myData.abc();
			};
		}.start();

		new Thread() {
			public void run() {
				myData.bcd();
			};
		}.start();

		new Thread() {
			public void run() {
				myData.cde();
			};
		}.start();
	}
}





























chap15_thread-master\src\sec04_synchronizedmethodandblock\EX05_KeyObject_2\KeyObject_2.java"
package sec04_synchronizedmethodandblock.EX05_KeyObject_2;

class MyData {
	synchronized void abc() {
		for(int i=0; i<3; i++) {
			System.out.println(i + "sec");
			try { Thread.sleep(1000); } catch (InterruptedException e) {}
		}
	}

	synchronized void bcd() {
		for(int i=0; i<3; i++) {
			System.out.println(i + "초");
			try { Thread.sleep(1000); } catch (InterruptedException e) {}
		}
	}

	void cde() {
		synchronized(new Object()) {
			for(int i=0; i<3; i++) {
				System.out.println(i + "번째");
				try { Thread.sleep(1000); } catch (InterruptedException e) {}
			}
		}
	}
}

public class KeyObject_2 {
	public static void main(String[] args) {
		//#공유객체
		MyData myData = new MyData();

		//#세개의 쓰레드가 각각의 메서드 호출
		new Thread() {
			public void run() {
				myData.abc();
			};
		}.start();

		new Thread() {
			public void run() {
				myData.bcd();
			};
		}.start();

		new Thread() {
			public void run() {
				myData.cde();
			};
		}.start();
	}
}





























chap15_thread-master\src\sec05_threadstates\EX01_NewRunnableTerminated\NewRunnableTerminated.java"
package sec05_threadstates.EX01_NewRunnableTerminated;

public class NewRunnableTerminated {
	public static void main(String[] args) {
		//#쓰레드 상태 저장 클래스
		Thread.State state;

		//#1. 객체 생성 (NEW)
		Thread myThread = new Thread() {
			@Override
			public void run() {
				for(long i=0; i<1000000000L ; i++) {} //시간지연
			}
		};
		state = myThread.getState();
		System.out.println("myThread state = "+ state); //NEW

		//#2. myThread 시작
		myThread.start();
		state = myThread.getState();
		System.out.println("myThread state = "+ state); //Runnable

		//#3. myThread 종료
		try {
			myThread.join();
		} catch (InterruptedException e) {	}

		state = myThread.getState();
		System.out.println("myThread state = "+ state); //TERMINATED
	}
}

chap15_thread-master\src\sec05_threadstates\EX02_YieldInRunnableState\YieldInRunnableState.java"
package sec05_threadstates.EX02_YieldInRunnableState;

class MyThread extends Thread {
	boolean yieldFlag;
	@Override
	public void run() {
		while(true) {
			if(yieldFlag) {
				Thread.yield();
			} else {
				System.out.println(getName() + " 실행");
				for(long i=0; i<1000000000L ; i++) {} //시간지연
			}
		}
	}
}

public class YieldInRunnableState {
	public static void main(String[] args) {
		MyThread thread1 = new MyThread();
		thread1.setName("thread1");
		thread1.yieldFlag=false;
		thread1.setDaemon(true);
		thread1.start();

		MyThread thread2 = new MyThread();
		thread2.setName("thread2");
		thread2.yieldFlag=true;
		thread2.setDaemon(true);
		thread2.start();

		//#1. 6초 지연 (1초마다 한번씩 양보)
		for(int i=0; i<6; i++) {
			try { Thread.sleep(1000); } catch (InterruptedException e) {}
			thread1.yieldFlag=!thread1.yieldFlag;
			thread2.yieldFlag=!thread2.yieldFlag;
		}

	}


}

chap15_thread-master\src\sec05_threadstates\EX03_TimedWaiting_Sleep\TimedWaiting_Sleep.java"
package sec05_threadstates.EX03_TimedWaiting_Sleep;

class MyThread extends Thread {
	@Override
	public void run() {
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			System.out.println(" -- sleep() 진행중 interrupt() 발생");
			for(long i=0; i<1000000000L ; i++) {} //시간지연
		}
	}
}

public class TimedWaiting_Sleep {
	public static void main(String[] args) {

		MyThread myThread = new MyThread();
		myThread.start();

		try {Thread.sleep(100);} catch (InterruptedException e) {} //쓰레드 시작 준비시간
		System.out.println("MyThread State = " + myThread.getState()); //TIMED_WAITING

		myThread.interrupt();
		try {Thread.sleep(100);} catch (InterruptedException e) {} //인터럽트 준비시간
		System.out.println("MyThread State = " + myThread.getState()); //RUNNABLE
	}
}

chap15_thread-master\src\sec05_threadstates\EX04_TimedWaiting_Join\TimedWaiting_Join.java"
package sec05_threadstates.EX04_TimedWaiting_Join;


class MyThread1 extends Thread {
	@Override
	public void run() {
		for(long i=0; i<1000000000L ; i++) {} //시간지연
	}
}

class MyThread2 extends Thread {
	MyThread1 myThread1;
	public MyThread2(MyThread1 myThread1) {
		this.myThread1 = myThread1;
	}

	@Override
	public void run() {
		try {
			myThread1.join(3000);
		} catch (InterruptedException e) {
			System.out.println(" -- join(...) 진행중 interrupt() 발생");
			for(long i=0; i<1000000000L ; i++) {} //시간지연
		}
	}
}

public class TimedWaiting_Join {
	public static void main(String[] args) {

		//#1. 객체 생성
		MyThread1 myThread1 = new MyThread1();
		MyThread2 myThread2 = new MyThread2(myThread1);
		myThread1.start();
		myThread2.start();

		try {Thread.sleep(100);} catch (InterruptedException e) {} //쓰레드 시작 준비 시간
		System.out.println("MyThread1 State = " + myThread1.getState()); //RUNNABLE
		System.out.println("MyThread2 State = " + myThread2.getState()); //TIMED_WAITING

		myThread2.interrupt();
		try {Thread.sleep(100);} catch (InterruptedException e) {} //인터럽트 준비 시간
		System.out.println("MyThread1 State = " + myThread1.getState()); //RUNNABLE
		System.out.println("MyThread2 State = " + myThread2.getState()); //RUNNABLE

	}
}

chap15_thread-master\src\sec05_threadstates\EX05_BlockedState\BlockedState.java"
package sec05_threadstates.EX05_BlockedState;

class MyBlockTest {
	//#1. 공유객체
	MyClass mc = new MyClass();

	//#2. 세 개의 쓰레드 필드 생성
	Thread t1 = new Thread("thread1") {
		public void run() {
			mc.syncMethod();
		};
	};
	Thread t2 = new Thread("thread2") {
		public void run() {
			mc.syncMethod();
		};
	};
	Thread t3 = new Thread("thread3") {
		public void run() {
			mc.syncMethod();
		};
	};

	void startAll() {
		t1.start();
		t2.start();
		t3.start();
	}

	class MyClass {
		synchronized void syncMethod() {
			try {Thread.sleep(100);} catch (InterruptedException e) {} //쓰레드 시작 준비 시간
			System.out.println("===="+Thread.currentThread().getName()+"====");
			System.out.println("thread1->" +t1.getState());
			System.out.println("thread2->" +t2.getState());
			System.out.println("thread3->" +t3.getState());
			for(long i=0; i<1000000000L ; i++) {} //시간지연
		}
	}
}

public class BlockedState {
	public static void main(String[] args) {
		MyBlockTest mbt = new MyBlockTest();
		mbt.startAll();
	}
}

chap15_thread-master\src\sec05_threadstates\EX06_Waiting_WaitNotify_1\Waiting_WaitNotify_1.java"
package sec05_threadstates.EX06_Waiting_WaitNotify_1;

class DataBox {
	int data;
	synchronized void inputData(int data) {
		this.data = data;
		System.out.println("입력데이터 : "+data);
	}
	synchronized void outputData() {
		System.out.println("출력데이터 : "+data);
	}
}

public class Waiting_WaitNotify_1 {
	public static void main(String[] args) {
		DataBox dataBox = new DataBox();
		Thread t1 = new Thread() {
			public void run() {
				for(int i=1; i<9; i++) {
					dataBox.inputData(i);
				}
			};
		};

		Thread t2 = new Thread() {
			public void run() {
				for(int i=1; i<9; i++) {
					dataBox.outputData();
				}
			};
		};

		t1.start();
		t2.start();
	}

}

chap15_thread-master\src\sec05_threadstates\EX07_Waiting_WaitNotify_2\Waiting_WaitNotify_2.java"
package sec05_threadstates.EX07_Waiting_WaitNotify_2;

class DataBox {
	boolean isEmpty = true;
	int data;
	synchronized void inputData(int data) {
		if(!isEmpty) {
			try { wait(); } catch (InterruptedException e) {} //WAITING
		}
		this.data = data;
		isEmpty=false;
		System.out.println("입력데이터 : "+data);
		notify();
	}
	synchronized void outputData() {
		if(isEmpty) {
			try { wait(); } catch (InterruptedException e) {} //WAITING
		}
		isEmpty = true;
		System.out.println("출력데이터 : "+data);
		notify();
	}
}

public class Waiting_WaitNotify_2 {
	public static void main(String[] args) {
		DataBox dataBox = new DataBox();
		Thread t1 = new Thread() {
			public void run() {
				for(int i=1; i<9; i++) {
					dataBox.inputData(i);
				}
			};
		};

		Thread t2 = new Thread() {
			public void run() {
				for(int i=1; i<9; i++) {
					dataBox.outputData();
				}
			};
		};

		t1.start();
		t2.start();
	}
}

chap16_generic-master\src\sec02_genericclass\EX01_SingleGenericArgument\SingleGenericArgument.java"
package sec02_genericclass.EX01_SingleGenericArgument;

class MyClass<T> {
	private T t;
	public T get() {
		return t;
	}
	public void set(T t) {
		this.t = t;
	}
}

public class SingleGenericArgument {
	public static void main(String[] args) {
		MyClass<String> mc1 = new MyClass<String>();
		mc1.set("안녕");
		System.out.println(mc1.get());
		MyClass<Integer> mc2 = new MyClass<>();
		mc2.set(100);
		System.out.println(mc2.get());
//		MyClass<Integer> mc3 = new MyClass<>();
//		mc3.set("안녕"); //오류 강한타입체크
	}
}

chap16_generic-master\src\sec02_genericclass\EX02_TwoGenericArguments\TwoGenericArguments.java"
package sec02_genericclass.EX02_TwoGenericArguments;

class KeyValue<K,V> {
	private K key;
	private V value;
	public K getKey() {
		return key;
	}
	public void setKey(K key) {
		this.key = key;
	}
	public V getValue() {
		return value;
	}
	public void setValue(V value) {
		this.value = value;
	}
}

public class TwoGenericArguments {
	public static void main(String[] args) {
		KeyValue<String, Integer> kv1 = new KeyValue<>();
		kv1.setKey("사과");
		kv1.setValue(1000);
		String key1 = kv1.getKey();
		int value1 = kv1.getValue();
		System.out.println("key:"+ key1 + " value:" +value1);


		KeyValue<Integer, String> kv2 = new KeyValue<>();
		kv2.setKey(404);
		kv2.setValue("Not Found(요청한 페이지를 찾을 수 없습니다.)");
		int key2 = kv2.getKey();
		String value2 = kv2.getValue();
		System.out.println("key:"+ key2 + " value:" +value2);


		KeyValue<String, Void> kv3 = new KeyValue<>();
		kv3.setKey("키값만 사용");
		String key3 = kv3.getKey();
		System.out.println("key:" + key3);
	}
}


































chap16_generic-master\src\sec02_genericclass\EX03_Solution2_Generic\Solution2_Generic.java"
package sec02_genericclass.EX03_Solution2_Generic;

class Apple{}
class Pencil{}

class Goods<T> {
	private T t;
	public T get() {
		return t;
	}
	public void set(T t) {
		this.t = t;
	}
}

public class Solution2_Generic {
	public static void main(String[] args) {
		//#1. Goods을 통해서 Apple 객체 추가 및 가져오기
		Goods<Apple> goods1 = new Goods<>();
		goods1.set(new Apple());
		Apple apple = goods1.get(); //다운캐스팅 필요 없음

		//#2. Goods을 통해서 Pencil 객체 추가 및 가져오기
		Goods<Pencil> goods2 = new Goods<>();
		goods2.set(new Pencil());
		Pencil pencil = goods2.get();

		//#3. 잘못된 타입선언
		Goods<Apple> goods3 = new Goods<>();
		goods3.set(new Apple());
//		Pencil pencil2 = goods3.get(); //강한타입체크
	}
}

chap16_generic-master\src\sec03_genericmethod\EX01_GenericMethod\GenericMethod.java"
package sec03_genericmethod.EX01_GenericMethod;

//일반클래스 안에 제네릭 메서드
class GenericMethods{
	public <T> T method1(T t) {
		return t;
	}
	public <T> boolean method2(T t1, T t2) {
		return t1.equals(t2);
	}
	public <K,V> void method3(K k, V v) {
		System.out.println(k + ":" + v);
	}
}

public class GenericMethod {
	public static void main(String[] args) {

		GenericMethods gm = new GenericMethods();
		String str1 = gm.<String>method1("안녕");
		String str2 = gm.method1("안녕");
		System.out.println(str1);
		System.out.println(str2);

		boolean bool1 = gm.<Double>method2(2.5, 2.5);
		boolean bool2 = gm.method2(2.5, 2.5);
		System.out.println(bool1);
		System.out.println(bool2);

		gm.<String, Integer>method3("국어", 80);
		gm.method3("국어", 80);
	}
}

chap16_generic-master\src\sec03_genericmethod\EX02_AvailableMethodInGenericMethod\AvailableMethodInGenericMethod.java"
package sec03_genericmethod.EX02_AvailableMethodInGenericMethod;

class A {
	public <T> void method(T t) {
		//System.out.println(t.length()); //불가능 : Object 메서드만 호출가능
		System.out.println(t.equals("안녕")); //Object 메서드만 호출가능
	}
}

public class AvailableMethodInGenericMethod {
	public static void main(String[] args) {

		A a = new A();
		a.<String>method("안녕");

	}
}

chap16_generic-master\src\sec04_boundedtype\EX01_BoundedTypeOfGenericClass\BoundedTypeOfGenericClass.java"
package sec04_boundedtype.EX01_BoundedTypeOfGenericClass;

class A {}
class B extends A {}
class C extends B {}

class D <T extends B> { //B와 C만 올수 있음
	private T t;
	public T get() {
		return t;
	}
	public void set(T t) {
		this.t = t;
	}
}

public class BoundedTypeOfGenericClass {
	public static void main(String[] args) {
//		D<A> d1 = new D<>(); //불가능
		D<B> d2 = new D<>();
		D<C> d3 = new D<>();
		D d4 = new D(); // = D<B> d4 = new D<>();

		d2.set(new B());
		d2.set(new C());

//		d3.set(new B()); //불가능
		d3.set(new C());

		d4.set(new B());
		d4.set(new C());
	}
}

chap16_generic-master\src\sec04_boundedtype\EX02_BoundedTypeOfGenericMethod\BoundedTypeOfGenericMethod.java"
package sec04_boundedtype.EX02_BoundedTypeOfGenericMethod;

class A {
	public <T extends Number> void method1(T t) {
		System.out.println(t.intValue());
	}
}

interface MyInterface {
	public abstract void print();
}

class B {
	public <T extends MyInterface> void method1(T t) {
		t.print();
	}
}

public class BoundedTypeOfGenericMethod {
	public static void main(String[] args) {
		A a = new A();
		a.method1(5.8); // = a.<Double>method1(5.8);

		B b = new B();
		b.method1(new MyInterface() {
			@Override
			public void print() {
				System.out.println("print() 구현");
			}
		});
	}
}

chap16_generic-master\src\sec04_boundedtype\EX03_BoundedTypeOfInputArguments\BoundedTypeOfInputArguments.java"
package sec04_boundedtype.EX03_BoundedTypeOfInputArguments;

class A {}
class B extends A {}
class C extends B {}
class D extends C {}

class Goods<T> {
	private T t;
	public T get() {
		return t;
	}
	public void set(T t) {
		this.t = t;
	}
}

class Test {
	void method1(Goods<A> g) {} //case1
	void method2(Goods<?> g) {} //case2
	void method3(Goods<? extends B> g) {} //case3
	void method4(Goods<? super B> g) {} //case4
}

public class BoundedTypeOfInputArguments {
	public static void main(String[] args) {
		Test t = new Test();

		//#1. case1
		t.method1(new Goods<A>());
//		t.method1(new Goods<B>());
//		t.method1(new Goods<C>());
//		t.method1(new Goods<D>());

		//#2. case2
		t.method2(new Goods<A>());
		t.method2(new Goods<B>());
		t.method2(new Goods<C>());
		t.method2(new Goods<D>());

		//#3. case3
//		t.method3(new Goods<A>());
		t.method3(new Goods<B>());
		t.method3(new Goods<C>());
		t.method3(new Goods<D>());

		//#4. case4
		t.method4(new Goods<A>());
		t.method4(new Goods<B>());
//		t.method4(new Goods<C>());
//		t.method4(new Goods<D>());
	}
}




























chap16_generic-master\src\sec05_inheritanceofgeneric\EX01_InheritanceGenericClass\InheritanceGenericClass.java"
package sec05_inheritanceofgeneric.EX01_InheritanceGenericClass;

class Parent<T> {
	T t;
	public T getT() {
		return t;
	}
	public void setT(T t) {
		this.t = t;
	}
}

class Child1<T> extends Parent<T>{

}

class Child2<T, V> extends Parent<T>{
	V v;
	public V getV() {
		return v;
	}
	public void setV(V v) {
		this.v = v;
	}
}

public class InheritanceGenericClass {
	public static void main(String[] args) {
		//#1. 부모제네릭클래스
		Parent<String> p = new Parent<>();
		p.setT("부모제네릭클래스");
		System.out.println(p.getT());

		//#2. 자식클래스1
		Child1<String> c1 = new Child1<>();
		c1.setT("자식1 제네릭클래스");
		System.out.println(c1.getT());

		//#3. 자식클래스2
		Child2<String, Integer> c2 = new Child2<>();
		c2.setT("자식2 제네릭클래스");
		c2.setV(100);
		System.out.println(c2.getT());
		System.out.println(c2.getV());
	}
}


chap16_generic-master\src\sec05_inheritanceofgeneric\EX02_InheritanceGenericMethod\InheritanceGenericMethod.java"
package sec05_inheritanceofgeneric.EX02_InheritanceGenericMethod;

class Parent {
	<T extends Number> void print(T t) {
		System.out.println(t);
	}
}

class Child extends Parent {

}

public class InheritanceGenericMethod {
	public static void main(String[] args) {

		//#1. 부모클래스 제네릭메서드 이용
		Parent p = new Parent();
		p.<Integer>print(10);
		p.print(10);

		//#2. 자식클래스 제네릭메서드 이용
		Child c = new Child();
		c.<Double>print(5.8);
		c.print(5.8);
	}
}

chap17_collectionframework-master\src\sec01_list\EX03_ArrayListMethod\ArrayListMethod.java"
package sec01_list.EX03_ArrayListMethod;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ArrayListMethod {
	public static void main(String[] args) {

		List<Integer> aList1 = new ArrayList<Integer>();

		//#1. add(E element)
		aList1.add(3);
		aList1.add(4);
		aList1.add(5);
		System.out.println(aList1.toString()); //=~.println(aList1) [3, 4, 5]

		//#2. add(int index, E element)
		aList1.add(1, 6);
		System.out.println(aList1.toString()); //[3, 6, 4, 5]

		//#3. addAll(또 다른 리스트 객체)
		List<Integer> aList2 = new ArrayList<>();
		aList2.add(1);
		aList2.add(2);
		aList2.addAll(aList1);
		System.out.println(aList2); //[1, 2, 3, 6, 4, 5]

		//#4. addAll(int index, 또 다른 리스트 객체)
		List<Integer> aList3 = new ArrayList<>();
		aList3.add(1);
		aList3.add(2); //[1 2]
		aList3.addAll(1, aList3);
		System.out.println(aList3); //[1, 1, 2, 2]

		//#5. set(int index, E element)
		aList3.set(1,5);
		aList3.set(3,6);
		//aList3.set(4,7); //java.lang.IndexOutOfBoundsException:
		System.out.println(aList3); //[1, 5, 2, 6]

		//#6. remove(int index)
		aList3.remove(1); //1번 인덱스를 삭제해라
		System.out.println(aList3); //[1, 2, 6]

		//#7. remove(Object o)
		aList3.remove(new Integer(2));
		System.out.println(aList3); //[1, 6]

		//#8. clear()
		aList3.clear();
		System.out.println(aList3); //[]

		//#9. isEmpty()
		System.out.println(aList3.isEmpty()); //true

		//#10. size()
		System.out.println(aList3.size());//0
		aList3.add(1);
		aList3.add(2);
		aList3.add(3);
		System.out.println(aList3); //[1, 2, 3]
		System.out.println(aList3.size());//3

		//#11.get(int index)
		System.out.println("0번째 : " + aList3.get(0)); //1
		System.out.println("1번째 : " + aList3.get(1)); //2
		System.out.println("2번째 : " + aList3.get(2)); //3
		for(int i=0; i<aList3.size(); i++)
			System.out.println(i+"번째 : "+aList3.get(i));

		//#12. toArray() List-->Array
		Object[] object = aList3.toArray();
		System.out.println(Arrays.toString(object)); //[1, 2, 3]

		//#13-1. toArray(T[] t) -->  T[]
		Integer[] integer1 = aList3.toArray(new Integer[0]);
		System.out.println(Arrays.toString(integer1));

		//#13-2. toArray(T[] t) -->  T[]
		Integer[] integer2 = aList3.toArray(new Integer[5]);
		System.out.println(Arrays.toString(integer2));
	}
}


































chap17_collectionframework-master\src\sec01_list\EX04_VectorMethod\VectorMethod.java"
package sec01_list.EX04_VectorMethod;

import java.util.Arrays;
import java.util.List;
import java.util.Vector;

public class VectorMethod {
	public static void main(String[] args) {

		List<Integer> vector1 = new Vector<Integer>();

		//#1. add(E element)
		vector1.add(3);
		vector1.add(4);
		vector1.add(5);
		System.out.println(vector1.toString()); //=~.println(aList1) [3, 4, 5]

		//#2. add(int index, E element)
		vector1.add(1, 6);
		System.out.println(vector1.toString()); //[3, 6, 4, 5]

		//#3. addAll(또 다른 리스트 객체)
		List<Integer> vector2 = new Vector<>();
		vector2.add(1);
		vector2.add(2);
		vector2.addAll(vector1);
		System.out.println(vector2); //[1, 2, 3, 6, 4, 5]

		//#4. addAll(int index, 또 다른 리스트 객체)
		List<Integer> vector3 = new Vector<>();
		vector3.add(1);
		vector3.add(2); //[1 2]
		vector3.addAll(1, vector3);
		System.out.println(vector3); //[1, 1, 2, 2]

		//#5. set(int index, E element)
		vector3.set(1,5);
		vector3.set(3,6);
		//aList3.set(4,7); //java.lang.IndexOutOfBoundsException:
		System.out.println(vector3); //[1, 5, 2, 6]

		//#6. remove(int index)
		vector3.remove(1); //1번 인덱스를 삭제해라
		System.out.println(vector3); //[1, 2, 6]

		//#7. remove(Object o)
		vector3.remove(new Integer(2));
		System.out.println(vector3); //[1, 6]

		//#8. clear()
		vector3.clear();
		System.out.println(vector3); //[]

		//#9. isEmpty()
		System.out.println(vector3.isEmpty()); //true

		//#10. size()
		System.out.println(vector3.size());//0
		vector3.add(1);
		vector3.add(2);
		vector3.add(3);
		System.out.println(vector3); //[1, 2, 3]
		System.out.println(vector3.size());//3

		//#11.get(int index)
		System.out.println("0번째 : " + vector3.get(0)); //1
		System.out.println("1번째 : " + vector3.get(1)); //2
		System.out.println("2번째 : " + vector3.get(2)); //3
		for(int i=0; i<vector3.size(); i++)
			System.out.println(i+"번째 : "+vector3.get(i));

		//#12. toArray() List-->Array
		Object[] object = vector3.toArray();
		System.out.println(Arrays.toString(object)); //[1, 2, 3]

		//#13-1. toArray(T[] t) -->  T[]
		Integer[] integer1 = vector3.toArray(new Integer[0]);
		System.out.println(Arrays.toString(integer1));

		//#13-2. toArray(T[] t) -->  T[]
		Integer[] integer2 = vector3.toArray(new Integer[5]);
		System.out.println(Arrays.toString(integer2));
	}
}


































chap17_collectionframework-master\src\sec01_list\EX05_LinkedListMethod\LinkedListMethod.java"
package sec01_list.EX05_LinkedListMethod;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;

public class LinkedListMethod {
	public static void main(String[] args) {

		List<Integer> linkedlist1 = new LinkedList<Integer>();

		//#1. add(E element)
		linkedlist1.add(3);
		linkedlist1.add(4);
		linkedlist1.add(5);
		System.out.println(linkedlist1.toString()); //=~.println(aList1) [3, 4, 5]

		//#2. add(int index, E element)
		linkedlist1.add(1, 6);
		System.out.println(linkedlist1.toString()); //[3, 6, 4, 5]

		//#3. addAll(또 다른 리스트 객체)
		List<Integer> linkedlist2 = new LinkedList<>();
		linkedlist2.add(1);
		linkedlist2.add(2);
		linkedlist2.addAll(linkedlist2);
		System.out.println(linkedlist2); //[1, 2, 3, 6, 4, 5]

		//#4. addAll(int index, 또 다른 리스트 객체)
		List<Integer> linkedlist3 = new LinkedList<>();
		linkedlist3.add(1);
		linkedlist3.add(2); //[1 2]
		linkedlist3.addAll(1, linkedlist3);
		System.out.println(linkedlist3); //[1, 1, 2, 2]

		//#5. set(int index, E element)
		linkedlist3.set(1,5);
		linkedlist3.set(3,6);
		//aList3.set(4,7); //java.lang.IndexOutOfBoundsException:
		System.out.println(linkedlist3); //[1, 5, 2, 6]

		//#6. remove(int index)
		linkedlist3.remove(1); //1번 인덱스를 삭제해라
		System.out.println(linkedlist3); //[1, 2, 6]

		//#7. remove(Object o)
		linkedlist3.remove(new Integer(2));
		System.out.println(linkedlist3); //[1, 6]

		//#8. clear()
		linkedlist3.clear();
		System.out.println(linkedlist3); //[]

		//#9. isEmpty()
		System.out.println(linkedlist3.isEmpty()); //true

		//#10. size()
		System.out.println(linkedlist3.size());//0
		linkedlist3.add(1);
		linkedlist3.add(2);
		linkedlist3.add(3);
		System.out.println(linkedlist3); //[1, 2, 3]
		System.out.println(linkedlist3.size());//3

		//#11.get(int index)
		System.out.println("0번째 : " + linkedlist3.get(0)); //1
		System.out.println("1번째 : " + linkedlist3.get(1)); //2
		System.out.println("2번째 : " + linkedlist3.get(2)); //3
		for(int i=0; i<linkedlist3.size(); i++)
			System.out.println(i+"번째 : "+linkedlist3.get(i));

		//#12. toArray() List-->Array
		Object[] object = linkedlist3.toArray();
		System.out.println(Arrays.toString(object)); //[1, 2, 3]

		//#13-1. toArray(T[] t) -->  T[]
		Integer[] integer1 = linkedlist3.toArray(new Integer[0]);
		System.out.println(Arrays.toString(integer1));

		//#13-2. toArray(T[] t) -->  T[]
		Integer[] integer2 = linkedlist3.toArray(new Integer[5]);
		System.out.println(Arrays.toString(integer2));




	}
}


































chap17_collectionframework-master\src\sec01_list\EX06_ArrayListVsLinkedList\ArrayListVsLinkedList.java"
package sec01_list.EX06_ArrayListVsLinkedList;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ArrayListVsLinkedList {
	public static void main(String[] args) {

		//#1. 데이터 추가시간 비교
		List<Integer> aList = new ArrayList<>();
		List<Integer> linkedList = new LinkedList<>();
		long startTime=0, endTime=0;

		//@1-1 ArrayList 데이터 추가시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			aList.add(0, i);
		}
		endTime = System.nanoTime();
		System.out.println("ArrayList 데이터 추가시간 = " +(endTime-startTime) + " ns");

		//@1-2 LinkedList 데이터 추가시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			linkedList.add(0, i);
		}
		endTime = System.nanoTime();
		System.out.println("LinkedList 데이터 추가시간 = " +(endTime-startTime) + " ns");


		//@2-1 ArrayList 데이터 검색시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			aList.get(i);
		}
		endTime = System.nanoTime();
		System.out.println("ArrayList 데이터 검색시간 = " +(endTime-startTime) + " ns");

		//@2-2 LinkedList 데이터 검색시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			linkedList.get(i);
		}
		endTime = System.nanoTime();
		System.out.println("LinkedList 데이터 검색시간 = " +(endTime-startTime) + " ns");


		//@3-1 ArrayList 데이터 제거시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			aList.remove(0);
		}
		endTime = System.nanoTime();
		System.out.println("ArrayList 데이터 제거시간 = " +(endTime-startTime) + " ns");

		//@3-2 LinkedList 데이터 제거시간
		startTime = System.nanoTime();
		for(int i=0; i<100000; i++) {
			linkedList.remove(0);
		}
		endTime = System.nanoTime();
		System.out.println("LinkedList 데이터 제거시간 = " +(endTime-startTime) + " ns");
	}
}

chap17_collectionframework-master\src\sec01_list\EX07_ListSummary\ListSummary.java"
package sec01_list.EX07_ListSummary;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;

public class ListSummary {
	public static void main(String[] args) {

		//1. ArrayList
		List<String> arrayList = new ArrayList<>();
		arrayList.add("다");
		arrayList.add("마");
		arrayList.add("나");
		arrayList.add("가");
		System.out.println(arrayList.toString()); //[다, 마, 나, 가]

		//2. Vector
		List<String> vector = new Vector<>();
		vector.add("다");
		vector.add("마");
		vector.add("나");
		vector.add("가");
		System.out.println(vector.toString()); //[다, 마, 나, 가]

		//3. LinkedList
		List<String> linkedList = new LinkedList<>();
		linkedList.add("다");
		linkedList.add("마");
		linkedList.add("나");
		linkedList.add("가");
		System.out.println(linkedList.toString()); //[다, 마, 나, 가]
	}
}

chap17_collectionframework-master\src\sec02_set\EX01_HashSetMethod\HashSetMethod.java"
package sec02_set.EX01_HashSetMethod;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetMethod {
	public static void main(String[] args) {

		Set<String> hSet1 = new HashSet<>();

		//#1. add(E element)
		hSet1.add("가");
		hSet1.add("나");
		hSet1.add("가");
		System.out.println(hSet1.toString()); //[가 나]

		//#2. addAll(다른 set 객체)
		Set<String> hSet2 = new HashSet<>();
		hSet2.add("나");
		hSet2.add("다");
		hSet2.addAll(hSet1);
		System.out.println(hSet2.toString()); //[가, 다, 나]

		//#3. remove(Object o)
		hSet2.remove("나");
		System.out.println(hSet2.toString()); //[가, 다]

		//#4. clear()
		hSet2.clear();
		System.out.println(hSet2.toString()); //[]

		//#5. isEmpty();
		System.out.println(hSet2.isEmpty()); //true

		//#6. contains (Object o)
		Set<String> hSet3 = new HashSet<>();
		hSet3.add("가");
		hSet3.add("나");
		hSet3.add("다");
		System.out.println(hSet3.contains("나")); //true
		System.out.println(hSet3.contains("라")); //false

		//#7. size()
		System.out.println(hSet3.size()); //3

		//#8. iterator()
		Iterator<String> iterator = hSet3.iterator();
		while(iterator.hasNext()) { //총 3바퀴
			System.out.println(iterator.next());
		}

		//#9. toArray()
		Object[] objArray = hSet3.toArray();
		System.out.println(Arrays.toString(objArray));  //[가, 다, 나]

		//#10-1. toArray(T[] t)
		String[] strArray1 = hSet3.toArray(new String[0]);
		System.out.println(Arrays.toString(strArray1)); //[가, 다, 나]

		//#10-2. toArray(T[] t)
		String[] strArray2 = hSet3.toArray(new String[5]);
		System.out.println(Arrays.toString(strArray2)); //[가, 다, 나, null, null]

	}
}

chap17_collectionframework-master\src\sec02_set\EX02_HashSetMachanism\HashSetMachanism.java"
package sec02_set.EX02_HashSetMachanism;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

class A {
	int data;
	public A(int data) {
		this.data = data;
	}
}

class B {
	int data;
	public B(int data) {
		this.data = data;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj instanceof B) {
			this.data = ((B)obj).data;
			return true;
		}
		return false;
	}
}

class C {
	int data;
	public C(int data) {
		this.data = data;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj instanceof C) {
			this.data = ((C)obj).data;
			return true;
		}
		return false;
	}
	@Override
	public int hashCode() {
		return Objects.hash(data);
	}
}

public class HashSetMachanism {
	public static void main(String[] args) {

		//#1. 어떤것도 오버라이딩 하지 않음
		Set<A> hashSet1 = new HashSet<>();
		A a1 = new A(3);
		A a2 = new A(3);
		System.out.println(a1==a2); //false
		System.out.println(a1.equals(a2)); //false
		System.out.println(a1.hashCode() + ", " + a2.hashCode());
		hashSet1.add(a1);
		hashSet1.add(a2);
		System.out.println(hashSet1.size()); //2
		System.out.println();


		//#2. equals 메서드만 오버라이딩
		Set<B> hashSet2 = new HashSet<>();
		B b1 = new B(3);
		B b2 = new B(3);
		System.out.println(b1==b2); //false
		System.out.println(b1.equals(b2)); //true
		System.out.println(b1.hashCode() + ", " + b2.hashCode());
		hashSet2.add(b1);
		hashSet2.add(b2);
		System.out.println(hashSet2.size()); //2
		System.out.println();

		//#2. equals + hashCode 메서드 오버라이딩
		Set<C> hashSet3 = new HashSet<>();
		C c1 = new C(3);
		C c2 = new C(3);
		System.out.println(c1==c2); //false
		System.out.println(c1.equals(c2)); //true
		System.out.println(c1.hashCode() + ", " + c2.hashCode());
		hashSet3.add(c1);
		hashSet3.add(c2);
		System.out.println(hashSet3.size()); //1

	}
}

chap17_collectionframework-master\src\sec02_set\EX03_LinkedHashSetMethod\LinkedHashSetMethod.java"
package sec02_set.EX03_LinkedHashSetMethod;

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

public class LinkedHashSetMethod {
	public static void main(String[] args) {

		Set<String> linkedSet1 = new LinkedHashSet<>();

		//#1. add(E element)
		linkedSet1.add("가");
		linkedSet1.add("나");
		linkedSet1.add("가");
		System.out.println(linkedSet1.toString()); //[가 나]

		//#2. addAll(다른 set 객체)
		Set<String> linkedSet2 = new LinkedHashSet<>();
		linkedSet2.add("나");
		linkedSet2.add("다");
		linkedSet2.addAll(linkedSet1);
		System.out.println(linkedSet2.toString()); //[나, 다, 가]

		//#3. remove(Object o)
		linkedSet2.remove("나");
		System.out.println(linkedSet2.toString()); //[다, 가]

		//#4. clear()
		linkedSet2.clear();
		System.out.println(linkedSet2.toString()); //[]

		//#5. isEmpty();
		System.out.println(linkedSet2.isEmpty()); //true

		//#6. contains (Object o)
		Set<String> linkedSet3 = new LinkedHashSet<>();
		linkedSet3.add("가");
		linkedSet3.add("나");
		linkedSet3.add("다");
		System.out.println(linkedSet3.contains("나")); //true
		System.out.println(linkedSet3.contains("라")); //false

		//#7. size()
		System.out.println(linkedSet3.size()); //3

		//#8. iterator()
		Iterator<String> iterator = linkedSet3.iterator();
		while(iterator.hasNext()) { //총 3바퀴
			System.out.println(iterator.next()); //가, 나 , 다
		}

		//#9. toArray()
		Object[] objArray = linkedSet3.toArray();
		System.out.println(Arrays.toString(objArray));  //[가, 나, 다]

		//#10-1. toArray(T[] t)
		String[] strArray1 = linkedSet3.toArray(new String[0]);
		System.out.println(Arrays.toString(strArray1)); //[가, 나, 다]

		//#10-2. toArray(T[] t)
		String[] strArray2 = linkedSet3.toArray(new String[5]);
		System.out.println(Arrays.toString(strArray2)); //[가, 나, 다, null, null]

	}
}

chap17_collectionframework-master\src\sec02_set\EX04_TreeSetMethod_1\TreeSetMethod_1.java"
package sec02_set.EX04_TreeSetMethod_1;

import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;

public class TreeSetMethod_1 {
	public static void main(String[] args) {

		TreeSet<Integer> treeSet = new TreeSet<>();
		for(int i=50; i>0; i-=2) {
			treeSet.add(i);
		}
		System.out.println(treeSet.toString()); //[2, 4, 6, ..., 50]

		//#1. first()
		System.out.println(treeSet.first()); //2
		//#2. last()
		System.out.println(treeSet.last()); //50
		//#3. lower(E element)
		System.out.println(treeSet.lower(26)); //24
		//#4. higher(E element)
		System.out.println(treeSet.higher(26)); //28
		//#5. floor(E element)
		System.out.println(treeSet.floor(25)); //24
		System.out.println(treeSet.floor(26)); //26
		//#6. ceiling(E element)
		System.out.println(treeSet.ceiling(25)); //26
		System.out.println(treeSet.ceiling(26)); //26
		System.out.println();

		//#7. pollFirst()
		int treeSetSize = treeSet.size();
		System.out.println(treeSetSize); //25
		for(int i=0; i<treeSetSize; i++) {
			System.out.print(treeSet.pollFirst() + " "); // 2 4 6 8 10 12 14 ... 50
		}
		System.out.println();
		System.out.println(treeSet.size()); //0

		//#8. pollLast()
		for(int i=50; i>0; i-=2) {
			treeSet.add(i);
		}
		treeSetSize = treeSet.size(); //25
		for(int i=0; i<treeSetSize; i++) {
			System.out.print(treeSet.pollLast() + " "); //50 48 46 44 42 40 ... 2
		}
		System.out.println();
		System.out.println(treeSet.size()); //0

		//#9. SortedSet<E> headSet(E element)
		for(int i=50; i>0; i-=2) { //[2, 4, 6, ..., 50]
			treeSet.add(i);
		}
		SortedSet<Integer> sSet = treeSet.headSet(20);
		System.out.println(sSet.toString()); //[2, 4, 6, 8, 10, 12, 14, 16, 18]

		//#10. NavigableSet<E> headSet(E element, boolean inclusive)
		NavigableSet<Integer> nSet = treeSet.headSet(20, true);
		System.out.println(nSet.toString()); //[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
		nSet = treeSet.headSet(20, false);
		System.out.println(nSet.toString()); //[2, 4, 6, 8, 10, 12, 14, 16, 18]

		//#11. SortedSet<E> tailSet(E element)
		sSet = treeSet.tailSet(20);
		System.out.println(sSet.toString()); // [20, 22, 24, ..., 50]

		//#12. NavigableSet<E> tailSet(E element, boolean inclusive)
		nSet = treeSet.tailSet(20, true);
		System.out.println(nSet.toString()); // [20, 22, 24, ..., 50]
		nSet = treeSet.tailSet(20, false);
		System.out.println(nSet.toString()); // [22, 24, ..., 50]

		//#13. SortedSet<E> subSet(E element, E element)
		sSet = treeSet.subSet(10, 20);
		System.out.println(sSet.toString()); // [10, 12, ... , 18]

		//#14. NavigableSet<E> subSet(E element, boolean inclusive, E element, boolean inclusive)
		nSet = treeSet.subSet(10, true, 20, false);
		System.out.println(nSet.toString()); // [10, 12, ... , 18]
		nSet = treeSet.subSet(10, false, 20, true);
		System.out.println(nSet.toString()); // [12, 14, ... , 20]

		//#15. NavigableSet<E> descendingSet()
		System.out.println(treeSet); //오름차순
		NavigableSet<Integer> descendingSet = treeSet.descendingSet();
		System.out.println(descendingSet); //내림차순
		descendingSet=descendingSet.descendingSet();
		System.out.println(descendingSet); //오름차순

	}
}






















chap17_collectionframework-master\src\sec02_set\EX05_TreeSetMethod_2\TreeSetMethod_2.java"
package sec02_set.EX05_TreeSetMethod_2;

import java.util.Comparator;
import java.util.TreeSet;

class MyClass {
	int data1;
	int data2;
	public MyClass(int data1, int data2) {
		this.data1=data1;
		this.data2=data2;
	}
}

class MyComparableClass implements Comparable<MyComparableClass>{
	int data1;
	int data2;
	public MyComparableClass(int data1, int data2) {
		this.data1=data1;
		this.data2=data2;
	}
	@Override
	public int compareTo(MyComparableClass o) { //크기비교의 기준을 여기서 설정 (음수, 0, 양수)
		if(this.data1<o.data1) return -1;
		else if(this.data1 == o.data1) return 0;
		else return 1;
	}
}

public class TreeSetMethod_2 {
	public static void main(String[] args) {

		//#1. Integer 크기 비교
		TreeSet<Integer> treeSet1 = new TreeSet<Integer>();
		Integer intValue1 = new Integer(20);
		Integer intValue2 = new Integer(10);
		treeSet1.add(intValue1);
		treeSet1.add(intValue2);
		System.out.println(treeSet1.toString());

		//#2. String 크기 비교
		TreeSet<String> treeSet2 = new TreeSet<String>();
		String str1 = "가나";
		String str2 = "다라";
		treeSet2.add(str1);
		treeSet2.add(str2);
		System.out.println(treeSet2.toString());

		//#3. MyClass 객체 크기 비교
//		TreeSet<MyClass> treeSet3 = new TreeSet<MyClass>();
//		MyClass myClass1 = new MyClass(2, 5);
//		MyClass myClass2 = new MyClass(3, 3);
//		treeSet3.add(myClass1);
//		treeSet3.add(myClass2);
//		System.out.println(treeSet3.toString());

		//#4. MyComparableClass 객체 크기 비교 방법#1
		TreeSet<MyComparableClass> treeSet4 = new TreeSet<MyComparableClass>();
		MyComparableClass myComparableClass1 = new MyComparableClass(2, 5);
		MyComparableClass myComparableClass2 = new MyComparableClass(3, 3);
		treeSet4.add(myComparableClass1);
		treeSet4.add(myComparableClass2);
		for(MyComparableClass mcc : treeSet4) {
			System.out.println(mcc.data1);
		}

		//#5. MyClass 객체 크기 비교 방법 #2.
		TreeSet<MyClass> treeSet5 = new TreeSet<MyClass>(new Comparator<MyClass>() {
			@Override
			public int compare(MyClass o1, MyClass o2) {
				if(o1.data1<o2.data1) return -1;
				else if(o1.data1 == o2.data1) return 0;
				else return 1;
			}
		});
		MyClass myClass1 = new MyClass(2, 5);
		MyClass myClass2 = new MyClass(3, 3);
		treeSet5.add(myClass1);
		treeSet5.add(myClass2);
		for(MyComparableClass mcc : treeSet5) {
			System.out.println(mcc.data1);
		}
	}
}

chap17_collectionframework-master\src\sec02_set\EX06_SetSummay\SetSummay.java"
package sec02_set.EX06_SetSummay;

import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

public class SetSummay {
	public static void main(String[] args) {

		//#1. HashSet
		Set<String> hashSet = new HashSet<>();
		hashSet.add("다");
		hashSet.add("마");
		hashSet.add("나");
		hashSet.add("가");
		System.out.println(hashSet.toString()); //[가, 다, 마, 나]

		//#2. LinkedHashSet
		Set<String> linkedHashSet = new LinkedHashSet<>();
		linkedHashSet.add("다");
		linkedHashSet.add("마");
		linkedHashSet.add("나");
		linkedHashSet.add("가");
		System.out.println(linkedHashSet.toString()); //[다 마 나 가]

		//#3. TreeSet
		Set<String> treeSet = new TreeSet<>();
		treeSet.add("다");
		treeSet.add("마");
		treeSet.add("나");
		treeSet.add("가");
		System.out.println(treeSet.toString()); //[가 나 다 마]
	}
}

chap17_collectionframework-master\src\sec03_map\EX01_HashMapMethod\HashMapMethod.java"
package sec03_map.EX01_HashMapMethod;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class HashMapMethod {
	public static void main(String[] args) {
		Map<Integer, String> hMap1 =  new HashMap<Integer, String>();

		//#1. put (K key, V value)
		hMap1.put(2, "나다라");
		hMap1.put(1, "가나다");
		hMap1.put(3, "다라마");
		System.out.println(hMap1.toString()); //{1=가나다, 2=나다라, 3=다라마}

		//#2. putAll(다른 맵객체)
		Map<Integer, String> hMap2 = new HashMap<Integer, String>();
		hMap2.putAll(hMap1);
		System.out.println(hMap2.toString()); //{1=가나다, 2=나다라, 3=다라마}

		//#3. replace(K key, V value)
		hMap2.replace(1, "가가가");
		hMap2.replace(4, "라라라"); //동작안함
		System.out.println(hMap2.toString()); //{1=가가가, 2=나다라, 3=다라마}

		//#4. replace(K key, V oldValue, V newValue)
		hMap2.replace(1, "가가가", "나나나");
		hMap2.replace(2, "다다다", "라라라"); //동작안함
		System.out.println(hMap2.toString()); //{1=나나나, 2=나다라, 3=다라마}

		//#5. V get(Object key)
		System.out.println(hMap2.get(1)); //나나나
		System.out.println(hMap2.get(2)); //나다라
		System.out.println(hMap2.get(3)); //다라마

		//#6. containsKey(Object key)
		System.out.println(hMap2.containsKey(1)); //true
		System.out.println(hMap2.containsKey(5)); //false

		//#7. containsValue(Object value)
		System.out.println(hMap2.containsValue("나나나")); //true
		System.out.println(hMap2.containsValue("다다다")); //false

		//#8. Set<K> keySet()
		Set<Integer> keySet = hMap2.keySet();
		System.out.println(keySet.toString()); //[1, 2, 3]

		//#9. Set<Map.Entry<K,V>> entrySet()
		Set<Map.Entry<Integer,String>> entrySet = hMap2.entrySet();
		System.out.println(entrySet.toString()); //[1=나나나, 2=나다라, 3=다라마]

		//#10. size();
		System.out.println(hMap2.size()); //3

		//#11. remove(Object key)
		hMap2.remove(1);
		hMap2.remove(4); //동작안함
		System.out.println(hMap2.toString()); //{2=나다라, 3=다라마}

		//#12. remove(Object key, Object value)
		hMap2.remove(2, "나다라");
		hMap2.remove(3, "다다다"); //동작안함
		System.out.println(hMap2.toString()); //{3=다라마}

		//#13. clear()
		hMap2.clear();
		System.out.println(hMap2.toString()); //{}
	}
}

chap17_collectionframework-master\src\sec03_map\EX02_HashMapMachanism\HashMapMachanism.java"
package sec03_map.EX02_HashMapMachanism;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

class A {
	int data;
	public A(int data) {
		this.data = data;
	}
}

class B {
	int data;
	public B(int data) {
		this.data = data;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj instanceof B) {
			this.data = ((B)obj).data;
			return true;
		}
		return false;
	}
}

class C {
	int data;
	public C(int data) {
		this.data = data;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj instanceof C) {
			this.data = ((C)obj).data;
			return true;
		}
		return false;
	}
	@Override
	public int hashCode() {
		return Objects.hash(data);
	}
}

public class HashMapMachanism {
	public static void main(String[] args) {

		//#1. 어떤것도 오버라이딩 하지 않음
		Map<A, String> hashMap1 = new HashMap<>();
		A a1 = new A(3);
		A a2 = new A(3);
		System.out.println(a1==a2); //false
		System.out.println(a1.equals(a2)); //false
		System.out.println(a1.hashCode() + ", " + a2.hashCode());
		hashMap1.put(a1, "첫번째");
		hashMap1.put(a2, "두번째");
		System.out.println(hashMap1.size()); //2
		System.out.println();


		//#2. equals 메서드만 오버라이딩
		Map<B, String> hashMap2 = new HashMap<>();
		B b1 = new B(3);
		B b2 = new B(3);
		System.out.println(b1==b2); //false
		System.out.println(b1.equals(b2)); //true
		System.out.println(b1.hashCode() + ", " + b2.hashCode());
		hashMap2.put(b1, "첫번째");
		hashMap2.put(b2, "두번째");
		System.out.println(hashMap2.size()); //2
		System.out.println();

		//#2. equals + hashCode 메서드 오버라이딩
		Map<C, String> hashMap3 = new HashMap<>();
		C c1 = new C(3);
		C c2 = new C(3);
		System.out.println(c1==c2); //false
		System.out.println(c1.equals(c2)); //true
		System.out.println(c1.hashCode() + ", " + c2.hashCode());
		hashMap3.put(c1, "첫번째");
		hashMap3.put(c2, "두번째");
		System.out.println(hashMap3.size()); //1

	}
}

chap17_collectionframework-master\src\sec03_map\EX03_HashTableMethod\HashTableMethod.java"
package sec03_map.EX03_HashTableMethod;

import java.util.Hashtable;
import java.util.Map;
import java.util.Set;

public class HashTableMethod {
	public static void main(String[] args) {
		Map<Integer, String> hTable1 =  new Hashtable<Integer, String>();

		//#1. put (K key, V value)
		hTable1.put(2, "나다라");
		hTable1.put(1, "가나다");
		hTable1.put(3, "다라마");
		System.out.println(hTable1.toString()); //{3=다라마, 2=나다라, 1=가나다}

		//#2. putAll(다른 맵객체)
		Map<Integer, String> hTable2 = new Hashtable<Integer, String>();
		hTable2.putAll(hTable1);
		System.out.println(hTable2.toString()); //{3=다라마, 2=나다라, 1=가나다}

		//#3. replace(K key, V value)
		hTable2.replace(1, "가가가");
		hTable2.replace(4, "라라라"); //동작안함
		System.out.println(hTable2.toString()); //{3=다라마, 2=나다라, 1=가나다}

		//#4. replace(K key, V oldValue, V newValue)
		hTable2.replace(1, "가가가", "나나나");
		hTable2.replace(2, "다다다", "라라라"); //동작안함
		System.out.println(hTable2.toString()); //{3=다라마, 2=나다라, 1=가나다}

		//#5. V get(Object key)
		System.out.println(hTable2.get(1)); //나나나
		System.out.println(hTable2.get(2)); //나다라
		System.out.println(hTable2.get(3)); //다라마

		//#6. containsKey(Object key)
		System.out.println(hTable2.containsKey(1)); //true
		System.out.println(hTable2.containsKey(5)); //false

		//#7. containsValue(Object value)
		System.out.println(hTable2.containsValue("나나나")); //true
		System.out.println(hTable2.containsValue("다다다")); //false

		//#8. Set<K> keySet()
		Set<Integer> keySet = hTable2.keySet();
		System.out.println(keySet.toString()); //[1, 2, 3]

		//#9. Set<Map.Entry<K,V>> entrySet()
		Set<Map.Entry<Integer,String>> entrySet = hTable2.entrySet();
		System.out.println(entrySet.toString()); //[1=나나나, 2=나다라, 3=다라마]

		//#10. size();
		System.out.println(hTable2.size()); //3

		//#11. remove(Object key)
		hTable2.remove(1);
		hTable2.remove(4); //동작안함
		System.out.println(hTable2.toString()); //{2=나다라, 3=다라마}

		//#12. remove(Object key, Object value)
		hTable2.remove(2, "나다라");
		hTable2.remove(3, "다다다"); //동작안함
		System.out.println(hTable2.toString()); //{3=다라마}

		//#13. clear()
		hTable2.clear();
		System.out.println(hTable2.toString()); //{}
	}
}

chap17_collectionframework-master\src\sec03_map\EX04_LinkedHashMapMethod\LinkedHashMapMethod.java"
package sec03_map.EX04_LinkedHashMapMethod;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

public class LinkedHashMapMethod {
	public static void main(String[] args) {
		Map<Integer, String> lhMap1 =  new LinkedHashMap<Integer, String>();

		//#1. put (K key, V value)
		lhMap1.put(2, "나다라");
		lhMap1.put(1, "가나다");
		lhMap1.put(3, "다라마");
		System.out.println(lhMap1.toString()); //{2=나다라, 1=가나다, 3=다라마}

		//#2. putAll(다른 맵객체)
		Map<Integer, String> lhMap2 = new LinkedHashMap<Integer, String>();
		lhMap2.putAll(lhMap1);
		System.out.println(lhMap2.toString()); //{2=나다라, 1=가나다, 3=다라마}

		//#3. replace(K key, V value)
		lhMap2.replace(1, "가가가");
		lhMap2.replace(4, "라라라"); //동작안함
		System.out.println(lhMap2.toString()); //{2=나다라, 1=가나다, 3=다라마}

		//#4. replace(K key, V oldValue, V newValue)
		lhMap2.replace(1, "가가가", "나나나");
		lhMap2.replace(2, "다다다", "라라라"); //동작안함
		System.out.println(lhMap2.toString()); //{2=나다라, 1=가나다, 3=다라마}

		//#5. V get(Object key)
		System.out.println(lhMap2.get(1)); //나나나
		System.out.println(lhMap2.get(2)); //나다라
		System.out.println(lhMap2.get(3)); //다라마

		//#6. containsKey(Object key)
		System.out.println(lhMap2.containsKey(1)); //true
		System.out.println(lhMap2.containsKey(5)); //false

		//#7. containsValue(Object value)
		System.out.println(lhMap2.containsValue("나나나")); //true
		System.out.println(lhMap2.containsValue("다다다")); //false

		//#8. Set<K> keySet()
		Set<Integer> keySet = lhMap2.keySet();
		System.out.println(keySet.toString()); //[2, 1, 3]

		//#9. Set<Map.Entry<K,V>> entrySet()
		Set<Map.Entry<Integer,String>> entrySet = lhMap2.entrySet();
		System.out.println(entrySet.toString()); //[2=나다라, 1=나나나, 3=다라마]

		//#10. size();
		System.out.println(lhMap2.size()); //3

		//#11. remove(Object key)
		lhMap2.remove(1);
		lhMap2.remove(4); //동작안함
		System.out.println(lhMap2.toString()); //{2=나다라, 3=다라마}

		//#12. remove(Object key, Object value)
		lhMap2.remove(2, "나다라");
		lhMap2.remove(3, "다다다"); //동작안함
		System.out.println(lhMap2.toString()); //{3=다라마}

		//#13. clear()
		lhMap2.clear();
		System.out.println(lhMap2.toString()); //{}
	}
}
chap17_collectionframework-master\src\sec03_map\EX05_TreeMapMethod_1\TreeMapMethod_1.java"
package sec03_map.EX05_TreeMapMethod_1;

import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.SortedMap;
import java.util.TreeMap;

public class TreeMapMethod_1 {
	public static void main(String[] args) {

		TreeMap<Integer, String> treeMap = new TreeMap<Integer, String>();
		for(int i=20; i>0; i-=2) {
			treeMap.put(i, i+" 번째 데이터");
		}
		System.out.println(treeMap.toString()); //{2=2 번째 데이터, 4=4 번째 데이터, ...,  20=20 번째 데이터}

		//#1. firstKey()
		System.out.println(treeMap.firstKey()); //2
		//#2. firstEntry()
		System.out.println(treeMap.firstEntry()); //2=2 번째 데이터
		//#3. lastKey()
		System.out.println(treeMap.lastKey()); //20
		//#4. lastEntry()
		System.out.println(treeMap.lastEntry()); //20=20 번째 데이터
		//#5. lowerKey(K key)
		System.out.println(treeMap.lowerKey(11)); //10
		System.out.println(treeMap.lowerKey(10)); //8
		//#6. higherKey(K key)
		System.out.println(treeMap.higherKey(11)); //12
		System.out.println(treeMap.higherKey(10)); //12

		//#7. pollFirsrtEntry()
		System.out.println(treeMap.pollFirstEntry()); //2=2 번째 데이터
		System.out.println(treeMap.toString()); //{4=4 번째 데이터, ...,  20=20 번째 데이터}

		//#8. pollLastEntry()
		System.out.println(treeMap.pollLastEntry()); //20=20 번째 데이터
		System.out.println(treeMap.toString()); //{4=4 번째 데이터, ...,  18=18 번째 데이터}

		//#9. SortedMap<K, V> headMap(K toKey)
		SortedMap<Integer, String> sortedMap = treeMap.headMap(8);
		System.out.println(sortedMap); //{4=4 번째 데이터, 6=6 번째 데이터}

		//#10. NavigableMap<K,V> headMap(K toKey, boolean inclusive)
		NavigableMap<Integer, String> navigableMap = treeMap.headMap(8, true);
		System.out.println(navigableMap); //{4=4 번째 데이터, 6=6 번째 데이터, 8=8 번째 데이터}

		//#11. SortedMap<K, V> tailMap(K toKey)
		sortedMap = treeMap.tailMap(14);
		System.out.println(sortedMap); //{14=14 번째 데이터, 16=16 번째 데이터, 18=18 번째 데이터}

		//#12. NavigableMap<K,V> headMap(K toKey, boolean inclusive)
		navigableMap = treeMap.tailMap(14, false);
		System.out.println(navigableMap); //{16=16 번째 데이터, 18=18 번째 데이터}

		//#13. SortedMap<K, V> subMap(K fromKey, K toKey)
		sortedMap = treeMap.subMap(6, 10);
		System.out.println(sortedMap); //{6=6 번째 데이터, 8=8 번째 데이터}

		//#14. NavigableMap<K,V> subMap(K toKey, boolean inclusive)
		navigableMap = treeMap.subMap(6, false, 10, true);
		System.out.println(navigableMap); //{8=8 번째 데이터, 10=10 번째 데이터}

		//#15. NavigableSet<K> descendingKeySet()
		NavigableSet<Integer> navigableSet = treeMap.descendingKeySet();
		System.out.println(navigableSet.toString()); //[18, 16, 14, 12, 10, 8, 6, 4]
		System.out.println(navigableSet.descendingSet()); //[4, 6, 8, 10, 12, 14, 16, 18]

		//#16. NavigableMap<K,V> descendingMap()
		navigableMap = treeMap.descendingMap();
		System.out.println(navigableMap.toString()); //{18=18 번째 데이터, ... 4=4 번째 데이터}
		System.out.println(navigableMap.descendingMap()); //{4=4 번째 데이터, ... 18=18 번째 데이터}
	}
}










chap17_collectionframework-master\src\sec03_map\EX06_TreeMapMethod_2\TreeMapMethod_2.java"
package sec03_map.EX06_TreeMapMethod_2;

import java.util.Comparator;
import java.util.TreeMap;

class MyClass {
	int data1;
	int data2;
	public MyClass(int data1, int data2) {
		this.data1=data1;
		this.data2=data2;
	}
	@Override
	public String toString() {
		return "data1="+data1+"을 가지고 있는 클래스";
	}
}


class MyComparableClass implements Comparable<MyComparableClass>{
	int data1;
	int data2;
	public MyComparableClass(int data1, int data2) {
		this.data1=data1;
		this.data2=data2;
	}
	@Override
	public int compareTo(MyComparableClass o) { //크기비교의 기준을 여기서 설정 (음수, 0, 양수)
		if(this.data1<o.data1) return -1;
		else if(this.data1 == o.data1) return 0;
		else return 1;
	}
	@Override
	public String toString() {
		return "data1="+data1+"을 가지고 있는 클래스";
	}
}

public class TreeMapMethod_2 {
	public static void main(String[] args) {

		//#1. Integer 크기 비교
		TreeMap<Integer, String> treeMap1 = new TreeMap<Integer, String>();
		Integer intValue1 = new Integer(20);
		Integer intValue2 = new Integer(10);
		treeMap1.put(intValue1, "가나다");
		treeMap1.put(intValue2, "나라다");
		System.out.println(treeMap1.toString()); //{10="가나다", 20="나라다"}

		//#2. String 크기 비교
		TreeMap<String, Integer> treeMap2 = new TreeMap<String, Integer>();
		String str1 = "가나";
		String str2 = "다라";
		treeMap2.put(str1, 10);
		treeMap2.put(str2, 20);
		System.out.println(treeMap2.toString()); //{가나=10, 다라=20}

		//#3. MyClass 객체 크기 비교
		/*
		TreeMap<MyClass, String> treeMap3 = new TreeMap<MyClass, String>();
		MyClass myClass1 = new MyClass(2, 5);
		MyClass myClass2 = new MyClass(3, 3);
		treeMap3.put(myClass1, "가나다");
		treeMap3.put(myClass2, "나라다");
		System.out.println(treeMap3.toString());
        */

		//#4. MyComparableClass 객체 크기 비교 방법#1
		TreeMap<MyComparableClass, String> treeMap4 = new TreeMap<MyComparableClass, String>();
		MyComparableClass myComparableClass1 = new MyComparableClass(2, 5);
		MyComparableClass myComparableClass2 = new MyComparableClass(3, 3);
		treeMap4.put(myComparableClass1, "가나다");
		treeMap4.put(myComparableClass2, "나라다");
		System.out.println(treeMap4);


		//#5. MyClass 객체 크기 비교 방법 #2.
		TreeMap<MyClass, String> treeMap5 = new TreeMap<MyClass, String>(new Comparator<MyClass>() {
			@Override
			public int compare(MyClass o1, MyClass o2) {
				if(o1.data1<o2.data1) return -1;
				else if(o1.data1 == o2.data1) return 0;
				else return 1;
			}
		});
		MyClass myClass1 = new MyClass(2, 5);
		MyClass myClass2 = new MyClass(3, 3);
		treeMap5.put(myClass1, "가나다");
		treeMap5.put(myClass2, "나라다");
		System.out.println(treeMap5);
	}
}

chap17_collectionframework-master\src\sec03_map\EX07_MapSummary\MapSummary.java"
package sec03_map.EX07_MapSummary;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeMap;

public class MapSummary {
	public static void main(String[] args) {

		//#1. HashMap 입력순서와 출력순서는 서로 다름
		Map<String, Integer> hashMap = new HashMap<>();
		hashMap.put("다", 30);
		hashMap.put("마", 40);
		hashMap.put("나", 50);
		hashMap.put("가", 60);
		System.out.println(hashMap.toString()); //{가=60, 다=30, 마=40, 나=50}

		//#2. HashTable 입력순서와 출력순서는 서로 다름
		Map<String, Integer> hashTable = new Hashtable<>();
		hashTable.put("다", 30);
		hashTable.put("마", 40);
		hashTable.put("나", 50);
		hashTable.put("가", 60);
		System.out.println(hashTable.toString()); //{가=60, 나=50, 마=40, 다=30}

		//#3. LinkedHashMap 입력순서와 출력순서는 항상 같음
		Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
		linkedHashMap.put("다", 30);
		linkedHashMap.put("마", 40);
		linkedHashMap.put("나", 50);
		linkedHashMap.put("가", 60);
		System.out.println(linkedHashMap.toString()); //{다=30, 마=40, 나=50, 가=60}

		//#4. TreeMap 입력순서와 상관없이 항상 오름차순으로 정렬 (키객체는 대소 비교 기준에 제공되어야 함)
		Map<String, Integer> treeMap = new TreeMap<>();
		treeMap.put("다", 30);
		treeMap.put("마", 40);
		treeMap.put("나", 50);
		treeMap.put("가", 60);
		System.out.println(treeMap.toString()); //{가=60, 나=50, 다=30, 마=40}

	}
}






chap17_collectionframework-master\src\sec04_stackandqueue\EX01_StatckMethod\StatckMethod.java"
package sec04_stackandqueue.EX01_StatckMethod;

import java.util.Stack;

public class StatckMethod {
	public static void main(String[] args) {

		Stack<Integer> stack = new Stack<Integer>();

		//#1. E push(E element)
		stack.push(2);
		stack.push(5);
		stack.push(3);
		stack.push(7);

		//#2. E peek();
		System.out.println(stack.peek()); //7
		System.out.println(stack.size()); //4
		System.out.println();

		//#3. search(Object o)
		System.out.println(stack.search(7)); //1
		System.out.println(stack.search(3)); //2
		System.out.println(stack.search(5)); //3
		System.out.println(stack.search(2)); //4
		System.out.println(stack.search(9)); //-1
		System.out.println();

		//#4. E pop()
		System.out.println(stack.pop()); //7
		System.out.println(stack.pop()); //3
		System.out.println(stack.pop()); //5
		System.out.println(stack.pop()); //2
		System.out.println();

		//#5. boolean empty()
		System.out.println(stack.empty()); //true


	}
}

chap17_collectionframework-master\src\sec04_stackandqueue\EX02_QueueMethod\QueueMethod.java"
package sec04_stackandqueue.EX02_QueueMethod;

import java.util.LinkedList;
import java.util.Queue;

public class QueueMethod {
	public static void main(String[] args) {

		//#1. 예외처리기능 미포함 메서드 첫번째 세트
		Queue<Integer> queue1 = new LinkedList<Integer>();
		//System.out.println(queue1.element());//NoSuchElementException
		//@1-1 add(E item)
		queue1.add(3);
		queue1.add(4);
		queue1.add(5);

		//@1-2 element()
		System.out.println(queue1.element()); //3

		//@1-3 E remove()
		System.out.println(queue1.remove()); //3
		System.out.println(queue1.remove()); //4
		System.out.println(queue1.remove()); //5
		//System.out.println(queue1.remove());//NoSuchElementException
		System.out.println();

		//#2. 예외처리기능 포함 메서드 두번째 세트
		Queue<Integer> queue2 = new LinkedList<Integer>();
		System.out.println(queue1.peek()); //null

		//@2-1. offer(E item)
		queue2.offer(3);
		queue2.offer(4);
		queue2.offer(5);

		//@2-2. E peek();
		System.out.println(queue2.peek()); //3

		//@2-3. E poll();
		System.out.println(queue2.poll()); //3
		System.out.println(queue2.poll()); //4
		System.out.println(queue2.poll()); //5
		System.out.println(queue2.poll()); //null
	}
}



















chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX03_RefOfIntanceMethod_Type1_1\RefOfIntanceMethod_Type1_1.java"
package sec01_lambdaexpression.EX03_RefOfIntanceMethod_Type1_1;

interface A {
	void abc();
}
class B {
	void bcd() {
		System.out.println("메서드");
	}
}

public class RefOfIntanceMethod_Type1_1 {
	public static void main(String[] args) {

		//#1. 인스턴스 메서드 참조 type1 익명이너클래스
		A a1 = new A() {
			@Override
			public void abc() {
				B b = new B();
				b.bcd();
			}
		};

		//#2. 람다식
		A a2 = ()->{
			B b = new B();
			b.bcd();
		};

		//#3. 인스턴스 참조 Type1의 표현
		B b = new B();
		A a3 = b::bcd;

		a1.abc();
		a2.abc();
		a3.abc();
	}
}

chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX04_RefOfIntanceMethod_Type1_2\RefOfIntanceMethod_Type1_2.java"
package sec01_lambdaexpression.EX04_RefOfIntanceMethod_Type1_2;

interface A {
	void abc(int k);
}

public class RefOfIntanceMethod_Type1_2 {
	public static void main(String[] args) {

		//#1 인스턴스 메서드 참조 type1 익명이너클래스
		A a1 = new A() {
			@Override
			public void abc(int k) {
				System.out.println(k);
			}
		};

		//#2. 람다식 줄인 표현
		A a2 = (int k)->{
			System.out.println(k);
		};

		//#3. 인스턴스 메서드 참조 type1
		A a3 = System.out::println;

		a1.abc(3);
		a2.abc(3);
		a3.abc(3);
	}
}





chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX05_RefOfStaticMethod\RefOfStaticMethod.java"
package sec01_lambdaexpression.EX05_RefOfStaticMethod;

interface A {
	void abc();
}

class B {
	static void bcd() {
		System.out.println("메서드");
	}
}

public class RefOfStaticMethod {
	public static void main(String[] args) {
		//#. 정적 메서드 참조
		//@1. 익명이너클래스 방법
		A a1 = new A() {
			@Override
			public void abc() {
				B.bcd();
			}
		};

		//@2. 람다식
		A a2 = ()->{ B.bcd(); };

		//@3. 정적메서드 참조
		A a3 = B::bcd;

		a1.abc();
		a2.abc();
		a3.abc();
	}
}











chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX06_RefOfInstanceMethod_Type2_1\RefOfInstanceMethod_Type2_1.java"
package sec01_lambdaexpression.EX06_RefOfInstanceMethod_Type2_1;

interface A {
	void abc(B b, int k);
}

class B {
	void bcd(int k) {
		System.out.println(k);
	}
}

public class RefOfInstanceMethod_Type2_1 {
	public static void main(String[] args) {
		//#인스턴스 메서드 참조 Type2
		//@1 익명이너클래스
		A a1 = new A() {
			@Override
			public void abc(B b, int k) {
				b.bcd(k);
			}
		};

		//@2. 람다식
		A a2 = (B b, int k)->{	b.bcd(k);};

		//@3. 인스턴스 메서드 참조 Type2
		A a3 = B::bcd;

		a1.abc(new B(), 3);
		a2.abc(new B(), 3);
		a3.abc(new B(), 3);

	}
}












chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX07_RefOfInstanceMethod_Type2_2\RefOfInstanceMethod_Type2_2.java"
package sec01_lambdaexpression.EX07_RefOfInstanceMethod_Type2_2;

interface A {
	int abc(String str);
}

public class RefOfInstanceMethod_Type2_2 {
	public static void main(String[] args) {
		//# 인스턴스 메서드 참조 Type2
		//@1. 익명이너클래스
		A a1 = new A() {
			@Override
			public int abc(String str) {
				return str.length();
			}
		};

		//@2.람다식
		A a2 = (String str)-> str.length();

		//@3. 인스턴스 메서드 참조 Type2
		A a3 = String::length;

		System.out.println(a1.abc("안녕"));
		System.out.println(a2.abc("안녕"));
		System.out.println(a3.abc("안녕"));

	}
}

chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX08_RefOfArrayConstructor\RefOfArrayConstructor.java"
package sec01_lambdaexpression.EX08_RefOfArrayConstructor;

interface A {
	int[] abc(int len);
}

public class RefOfArrayConstructor {
	public static void main(String[] args) {

		//# 배열의 생성자 참조
		//@1. 익명이너클래스
		A a1 = new A() {
			@Override
			public int[] abc(int len) {
				return new int[len];
			}
		};

		//@2. 람다식
		A a2 = (int len)->{
			return new int[len];
		};

		//@3. 배열의 생성자 참조
		A a3 = int[]::new;

		int[] array1 = a1.abc(3);
		System.out.println(array1.length); //3
		int[] array2 = a2.abc(3);
		System.out.println(array2.length); //3
		int[] array3 = a3.abc(3);
		System.out.println(array3.length); //3

	}
}

chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX09_RefOfClassConstructor_1\RefOfClassConstructor_1.java"
package sec01_lambdaexpression.EX09_RefOfClassConstructor_1;

interface A {
	B abc();
}

class B {
	B() {
		System.out.println("첫번째 생성자");
	}
	B(int k) {
		System.out.println("두번째 생성자");
	}
}

public class RefOfClassConstructor_1 {
	public static void main(String[] args) {
		//클래스 생성자 참조
		//@1 익명이너클래스
		A a1 = new A() {
			@Override
			public B abc() {
				return new B();
			}
		};

		//@2.람다식
		A a2 = ()-> new B();

		//@3. 클래스 생성자 참조
		A a3 = B::new;

		a1.abc(); //첫번째 생성자
		a2.abc(); //첫번째 생성자
		a3.abc(); //첫번째 생성자
	}
}







chap18_lambdaexpression-master\src\sec01_lambdaexpression\EX10_RefOfClassConstructor_2\RefOfClassConstructor_2.java"
package sec01_lambdaexpression.EX10_RefOfClassConstructor_2;

interface A {
	B abc(int k);
}

class B {

	  B() {
		  System.out.println("첫번째 생성자");
	  }
	  B(int k) {
		  System.out.println("두번째 생성자");
	  }

}

public class RefOfClassConstructor_2 {
	public static void main(String[] args) {
		// 클래스 생성자 참조
		// @1 익명이너클래스
		A a1 = new A() {
			@Override
			public B abc(int k) {
				return new B(3);
			}
		};

		// @2.람다식
		A a2 = (int k) -> new B(3);

		// @3. 클래스 생성자 참조
		A a3 = B::new;

		a1.abc(3); // 두번째 생성자
		a2.abc(3); // 두번째 생성자
		a3.abc(3); // 두번째 생성자
	}
}

chap18_lambdaexpression-master\src\sec02_functioninterfaceinjavaAPI\EX01_Consumer_FuntionalInterface\Consumer_FuntionalInterface.java"
package sec02_functioninterfaceinjavaAPI.EX01_Consumer_FuntionalInterface;

import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;

public class Consumer_FuntionalInterface {
	public static void main(String[] args) {

		//#1. 익명이너클래스를 이용한 객체 생성
		Consumer<String> c = new Consumer<String>() {
			@Override
			public void accept(String t) {
				System.out.println(t);
			}
		};

		//#2. 람다식 표현
		//@1. 표준 Consumer
		Consumer<String> c1 = t->System.out.println(t);
		c1.accept("Consumer<T> 함수형 인터페이스");

		//@2. 확장형 Consumer
		IntConsumer c2 = num->System.out.println("int 값="+num);
		LongConsumer c3 = num->System.out.println("long 값="+num);
		DoubleConsumer c4 = num->System.out.println("double 값="+num);
		BiConsumer<String, Integer> c5 = (name, age)->System.out.println("이름="+name + " 나이="+age);

		c2.accept(5);
		c3.accept(5L);
		c4.accept(7.8);
		c5.accept("홍길동", 16);
	}
}

chap18_lambdaexpression-master\src\sec02_functioninterfaceinjavaAPI\EX02_Suppler_FuntionalInterface\Suppler_FuntionalInterface.java"
package sec02_functioninterfaceinjavaAPI.EX02_Suppler_FuntionalInterface;

import java.util.function.BooleanSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.Supplier;

public class Suppler_FuntionalInterface {
	public static void main(String[] args) {

		//#1. 익명이너클래스 방법 객체 생성
		Supplier<String> s = new Supplier<String>() {
			@Override
			public String get() {
				return "Supplier<T> 함수형 인터페이스";
			}
		};
		System.out.println(s.get()); //Supplier<T> 함수형 인터페이스

		//#2. Supplier<T> 함수형 인터페이스
		//@1. 표준형
		Supplier<String> s1 = ()-> "Supplier<T> 함수형 인터페이스";
		System.out.println(s1.get()); //Supplier<T> 함수형 인터페이스

		//@2. 확장형
		BooleanSupplier s2 = ()->false;
		IntSupplier s3 = ()->2+3;
		LongSupplier s4 = ()->10L;
		DoubleSupplier s5 = ()->5.8;
		System.out.println(s2.getAsBoolean()); //false
		System.out.println(s3.getAsInt()); //5
		System.out.println(s4.getAsLong()); //10
		System.out.println(s5.getAsDouble()); //5.8

	}
}



chap18_lambdaexpression-master\src\sec02_functioninterfaceinjavaAPI\EX03_Predicate_FuntionalInterface\Predicate_FuntionalInterface.java"
package sec02_functioninterfaceinjavaAPI.EX03_Predicate_FuntionalInterface;

import java.util.function.BiPredicate;
import java.util.function.DoublePredicate;
import java.util.function.IntPredicate;
import java.util.function.LongPredicate;
import java.util.function.Predicate;

public class Predicate_FuntionalInterface {
	public static void main(String[] args) {

		//#1. 익명이너클래스 방법으로 객체 생성
		Predicate<String> p = new Predicate<String>() {
			@Override
			public boolean test(String t) {
				return (t.length()>0)? true:false;
			}
		};
		System.out.println(p.test("안녕")); //true

		//#2. Predicate<T>의 람다식 표현
		//@1. 표준형 Predicate<T>
		Predicate<String> p1 = (str)->(str.length()>0?true:false);
		System.out.println(p1.test("안녕")); //true
		System.out.println();

		//@2. 확장형 Predicate
		IntPredicate p2 = (num)->(num%2)==0?true:false;
		LongPredicate p3 = (num)->(num>100)?true:false;
		DoublePredicate p4 = (num)->(num>0)?true:false;
		BiPredicate<String, String> p5 = (str1, str2)->str1.equals(str2);

		System.out.println(p2.test(2)); //true
		System.out.println(p3.test(85L)); //false
		System.out.println(p4.test(-5.8)); //false
		System.out.println(p5.test("안녕", "안녕")); //true

	}
}






chap18_lambdaexpression-master\src\sec02_functioninterfaceinjavaAPI\EX04_Function_FunctionalInterface\Function_FunctionalInterface.java"
package sec02_functioninterfaceinjavaAPI.EX04_Function_FunctionalInterface;

import java.util.function.BiFunction;
import java.util.function.DoubleFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.LongFunction;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;

public class Function_FunctionalInterface {
	public static void main(String[] args) {

		//#1. 익명이너클래스 방법으로 객체 생성
		Function<String, Integer> f = new Function<String, Integer>() {
			@Override
			public Integer apply(String t) {
				return t.length();
			}
		};
		System.out.println(f.apply("안녕"));//2

		//#2. Function<T, R> 람다식 표현
		//@1. 표준형
		Function<String, Integer> f1 = str-> str.length();
		System.out.println(f1.apply("안녕"));//2

		//@2-1. 확장형 (입력(T)이 고정)
		IntFunction<Double> f2 = (num)->(double)num;; //int->double
		LongFunction<String> f3 = (num)->String.valueOf(num); //long->String
		DoubleFunction<Integer> f4 = (num)->(int)num;; //double->int
		BiFunction<String, Integer, String> f5 = (name, age)->"이름은 = " + name + " 나이는 = "+ age; //String, Integer->String

		System.out.println(f2.apply(10)); //10.0
		System.out.println(f3.apply(20L)); //20
		System.out.println(f4.apply(30.5)); //30
		System.out.println(f5.apply("홍길동", 16)); //이름은 = 홍길동 나이는 = 16
		System.out.println();

		//@2-2. 확장형 (출력(R)이 고정)
		ToIntFunction<String> f6 = (str)->str.length(); //String->int
		ToLongFunction<Double> f7 = (num)->num.longValue(); //double->long
		ToDoubleFunction<Integer> f8 = (num)->num/100.0; //Integer->double
		System.out.println(f6.applyAsInt("반갑습니다")); //5
		System.out.println(f7.applyAsLong(58.254)); //58
		System.out.println(f8.applyAsDouble(250)); //2.5
	}
}
chap18_lambdaexpression-master\src\sec02_functioninterfaceinjavaAPI\EX05_UnaryBinaryOperator_FunctionalInterface\UnaryBinaryOperator_FunctionalInterface.java"
package sec02_functioninterfaceinjavaAPI.EX05_UnaryBinaryOperator_FunctionalInterface;

import java.util.function.BinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.UnaryOperator;

public class UnaryBinaryOperator_FunctionalInterface {
	public static void main(String[] args) {

		//#1. 익명이너클래스를 이용한 객체 생성  Function<T, T> = UnaryOperator<T>
		UnaryOperator<Integer> uo = new UnaryOperator<Integer>() {
			@Override
			public Integer apply(Integer t) {
				return t*2;
			}
		};

		BinaryOperator<String> bo = new BinaryOperator<String>() {
			@Override
			public String apply(String t, String u) {
				return t+u;
			}
		};
		System.out.println(uo.apply(5)); //10
		System.out.println(bo.apply("안녕", "하세요")); //안녕하세요
		System.out.println();

		//#2. 람다식
		//@1. 표준형
		UnaryOperator<Integer> uo1 = value -> value*2;
		System.out.println(uo1.apply(5)); //10

		BinaryOperator<String> bo1 = (value1, value2)->value1+value2;
		System.out.println(bo1.apply("안녕", "하세요")); //안녕하세요
		System.out.println();

		//@2. 확장형
		IntUnaryOperator uo2 = (num)->num*10; //int->int
		LongUnaryOperator uo3 = (num)->num+20L; //long->long
		DoubleUnaryOperator uo4 = (num)->num*10.0; //double->double
		System.out.println(uo2.applyAsInt(10)); //100
		System.out.println(uo3.applyAsLong(20L)); //40
		System.out.println(uo4.applyAsDouble(30.5)); //305.0
		System.out.println();

		IntBinaryOperator bo2 = (num1, num2)->num1+num2; //int->int
		LongBinaryOperator bo3 = (num1, num2)->num1*num2; //long->long
		DoubleBinaryOperator bo4 = (num1, num2)->num1/num2; //double->double
		System.out.println(bo2.applyAsInt(10, 20)); //30
		System.out.println(bo3.applyAsLong(20L, 10L)); //200
		System.out.println(bo4.applyAsDouble(40.2, 12.0)); //3.35
	}
}























chap19_javaio-master\src\sec01_fileandcharset\EX03_EUCKRvsMS949\EUCKRvsMS949.java"
package sec01_fileandcharset.EX03_EUCKRvsMS949;

import java.io.UnsupportedEncodingException;

public class EUCKRvsMS949 {
	public static void main(String[] args) throws UnsupportedEncodingException {

		//#EUC-KR vs. MS949
		byte[] b1 = "a".getBytes("EUC-KR"); //문자열--> byte[]
		byte[] b2 = "a".getBytes("MS949");  //문자열--> byte[]

		System.out.println(b1.length); //1
		System.out.println(b2.length); //1

		System.out.println(new String(b1, "EUC-KR"));  //byte[] --> 문자열
		System.out.println(new String(b2, "MS949"));  //byte[] --> 문자열
		System.out.println();


		byte[] b3 = "가".getBytes("EUC-KR"); //문자열--> byte[]
		byte[] b4 = "가".getBytes("MS949");  //문자열--> byte[]

		System.out.println(b3.length); //2
		System.out.println(b4.length); //2

		System.out.println(new String(b3, "EUC-KR"));  //byte[] --> 문자열
		System.out.println(new String(b4, "MS949"));  //byte[] --> 문자열
		System.out.println();



		byte[] b5 = "봵".getBytes("EUC-KR"); //문자열--> byte[]
		byte[] b6 = "봵".getBytes("MS949");  //문자열--> byte[]

		System.out.println(b5.length); //1 ?
		System.out.println(b6.length); //2

		System.out.println(new String(b5, "EUC-KR"));  //byte[] --> 문자열
		System.out.println(new String(b6, "MS949"));  //byte[] --> 문자열
		System.out.println();

	}
}

chap19_javaio-master\src\sec01_fileandcharset\EX04_UTF16vsUTF8\UTF16vsUTF8.java"
package sec01_fileandcharset.EX04_UTF16vsUTF8;

import java.io.UnsupportedEncodingException;

public class UTF16vsUTF8 {
	public static void main(String[] args) throws UnsupportedEncodingException {

		//#UTF-16 vs. UTF-8
		byte[] b1 = "abc".getBytes("UTF-16"); //문자열--> byte[]
		byte[] b2 = "abc".getBytes("UTF-8");  //문자열--> byte[]

		System.out.println(b1.length); //FE FF + 6 = 8
		System.out.println(b2.length); //3

		for(byte b : b1)
			System.out.printf("%02X ", b);
		System.out.println();

		for(byte b : b2)
			System.out.printf("%02X ", b);
		System.out.println();

		System.out.println(new String(b1, "UTF-16"));  //byte[] --> 문자열
		System.out.println(new String(b2, "UTF-8"));  //byte[] --> 문자열
		System.out.println();


		byte[] b3 = "가나다".getBytes("UTF-16"); //문자열--> byte[]
		byte[] b4 = "가나다".getBytes("UTF-8");  //문자열--> byte[]

		System.out.println(b3.length); //FE FF + 6 = 8
		System.out.println(b4.length); //9

		for(byte b : b3)
			System.out.printf("%02X ", b);
		System.out.println();

		for(byte b : b4)
			System.out.printf("%02X ", b);
		System.out.println();

		System.out.println(new String(b3, "UTF-16"));  //byte[] --> 문자열
		System.out.println(new String(b4, "UTF-8"));  //byte[] --> 문자열
		System.out.println();
	}
}

chap19_javaio-master\src\sec01_fileandcharset\EX05_CreateChasetObject\CreateChasetObject.java"
package sec01_fileandcharset.EX05_CreateChasetObject;

import java.nio.charset.Charset;

public class CreateChasetObject {
	public static void main(String[] args) {

		Charset cs1 = Charset.defaultCharset();
		Charset cs2 = Charset.forName("MS949");
		Charset cs3 = Charset.forName("UTF-8");

		System.out.println(cs1); //UTF-8 / MS949
		System.out.println(cs2); //MS949
		System.out.println(cs3); //UTF-8

		System.out.println();

		System.out.println(Charset.isSupported("MS949")); //true
		System.out.println(Charset.isSupported("UTF-8")); //true
	}
}

chap19_javaio-master\src\sec01_fileandcharset\EX06_ByteArrayToFromString\ByteArrayToFromString.java"
package sec01_fileandcharset.EX06_ByteArrayToFromString;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;

public class ByteArrayToFromString {
	public static void main(String[] args) throws UnsupportedEncodingException {

		//#1 String getBytes() : String --> byte[] 분해
		byte[] array1 = "안녕".getBytes();
		byte[] array2 = "땡큐".getBytes(Charset.defaultCharset());
		byte[] array3 = "베리".getBytes(Charset.forName("MS949"));
		byte[] array4 = "감사".getBytes("UTF-8");

		System.out.println(array1.length); //6
		System.out.println(array2.length); //6
		System.out.println(array3.length); //4
		System.out.println(array4.length); //6

		//#2 new String(.)을 이용 : byte[] --> String 조합
		String str1 = new String(array1);
		String str2 = new String(array2, Charset.defaultCharset());
		String str3 = new String(array3, Charset.forName("MS949"));
		String str4 = new String(array4, "UTF-8");

		String str5 = new String(array3, "UTF-8");
		String str6 = new String(array4, "MS949");

		System.out.println(str1); //defaultCharset->defaultCharset
		System.out.println(str2); //defaultCharset->defaultCharset
		System.out.println(str3); //MS949->MS949
		System.out.println(str4); //UTF-8->UTF-8
		System.out.println(str5); //MS949->UTF-8 : ���� (깨짐)
		System.out.println(str6); //UTF-8->MS949: 媛먯궗(깨짐)

	}
}

chap19_javaio-master\src\sec02_fileinputoutputstream\EX01_FileInputStream_1\FileInputStream_1.java"
package sec02_fileinputoutputstream.EX01_FileInputStream_1;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStream_1 {
	public static void main(String[] args) throws IOException {
		//입력파일 생성
		File inFile = new File("src/sec02_fileinputoutputstream/files/FileInputStream1.txt");

		//InputStream 객체 생성
		InputStream is = new FileInputStream(inFile);

		int data;
		while((data=is.read())!=-1) {
			System.out.println("읽은 데이터 : "+ (char)data + "남은 바이트수 : " + is.available());
		}

		//InputStream 자원 반납
		is.close();


	}
}

chap19_javaio-master\src\sec02_fileinputoutputstream\EX02_FileInputStream_2\FileInputStream_2.java"
package sec02_fileinputoutputstream.EX02_FileInputStream_2;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileInputStream_2 {
	public static void main(String[] args) throws IOException {

		//입력파일 생성
        File inFile = new File("src/sec02_fileinputoutputstream/files/FileInputStream1.txt");

        //#1. 1-byte 단위 읽기
        InputStream is1 = new FileInputStream(inFile);
        int data;
        while((data=is1.read())!=-1) {
            System.out.print((char)data);
        }
        is1.close();
        System.out.println();
        System.out.println();

        //#2. n-byte 단위 읽기 (byte[]의 처음 위치에서 부터 읽은 데이터 저장)
        InputStream is2 = new FileInputStream(inFile);
        byte[] byteArray1 = new byte[9];
        int count1;
        while((count1 = is2.read(byteArray1))!=-1) { // count1 = 9, 9, 2, -1
            for(int i=0; i<count1; i++) {
                System.out.print((char)byteArray1[i]);
            }
            System.out.println(" : count1 = " + count1);
        }
        is2.close();
        System.out.println();
        System.out.println();

        //#3. n-byte 단위 읽기  (length 만큼 앞에서부터 읽어와 byte[] offset 위치부터 넣어라)
        InputStream is3 = new FileInputStream(inFile);
        byte[] byteArray2 = new byte[9]; //최소 offset + length
        int offset = 3;
        int length = 6;
        int count2 = is3.read(byteArray2, offset, length);
        for(int i=0; i<offset+count2; i++) {
            System.out.print((char)byteArray2[i]);
        }
        is3.close();
    }
}











chap19_javaio-master\src\sec02_fileinputoutputstream\EX03_FileInputStream_3\FileInputStream_3.java"
package sec02_fileinputoutputstream.EX03_FileInputStream_3;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;

public class FileInputStream_3 {
	public static void main(String[] args) throws IOException {

		//입력파일 생성
        File inFile = new File("src/sec02_fileinputoutputstream/files/FileInputStream2.txt");

        //#2. n-byte 단위 읽기 (byte[]의 처음 위치에서 붙터 읽은 데이터 저장)
        InputStream is2 = new FileInputStream(inFile);
        byte[] byteArray1 = new byte[9];
        int count1;
        while((count1 = is2.read(byteArray1))!=-1) {
            String str = new String(byteArray1, 0, count1, Charset.forName("UTF-8"));
            System.out.print(str);
            System.out.println(" : count = " + count1);
        }
        is2.close();
        System.out.println();
        System.out.println();

        //#3. n-byte 단위 읽기  (length 만큼 앞에서부터 읽어와서 byte[] offset위치부터 넣어라)
        InputStream is3 = new FileInputStream(inFile);
        byte[] byteArray2 = new byte[9]; //최소 offset + length
        int offset = 3;
        int length = 6;
        int count2 = is3.read(byteArray2, offset, length);
        String str = new String(byteArray2, 0, offset+count2, Charset.defaultCharset());
        //String str = new String(byteArray2, offset, count2, Charset.defaultCharset());
        System.out.println(str);
        is3.close();
    }
}


chap19_javaio-master\src\sec02_fileinputoutputstream\EX04_FileOutputStream_1\FileOutputStream_1.java"
package sec02_fileinputoutputstream.EX04_FileOutputStream_1;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class FileOutputStream_1 {
	public static void main(String[] args) throws IOException {

		//입력파일 생성
		File outFile = new File("src/sec02_fileinputoutputstream/files/FileOutputStream1.txt");

		//#1. 1-byte 단위 쓰기
		OutputStream os1 = new FileOutputStream(outFile);
		os1.write('J');
		os1.write('A');
		os1.write('V');
		os1.write('A');
		os1.write('\r'); //13 //생략가능
		os1.write('\n'); //10 개행 /r/n

		os1.flush();
		os1.close();

		//#2. n-byte 단위 쓰기 (byte[]의 처음부터 끝까지 데이터를 쓰기)
		OutputStream os2 = new FileOutputStream(outFile, true); //내용 연결
		byte[] byteArray1 = "Hello!".getBytes();
		os2.write(byteArray1);
		os2.write('\n');
		os2.flush();
		os2.close();

		//#3. n-byte 단위 쓰기 (byte[]의 offset부터 length 개의  byte 데이터를 쓰기)
		OutputStream os3 = new FileOutputStream(outFile, true); //내용 연결
		byte[] byteArray2 = "Better the last smile than the first laughter".getBytes();
		os3.write(byteArray2, 7, 8);

		os3.flush();
		os3.close();

	}
}










chap19_javaio-master\src\sec02_fileinputoutputstream\EX05_FileOutputStream_2\FileOutputStream_2.java"
package sec02_fileinputoutputstream.EX05_FileOutputStream_2;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;

public class FileOutputStream_2 {
	public static void main(String[] args) throws IOException {

		//입력파일 생성
		File outFile = new File("src\\sec02_fileinputoutputstream\\files\\FileOutputStream2.txt");


		//#2. n-byte 단위 쓰기 (byte[]의 처음부터 끝까지 데이터를 쓰기)
		OutputStream os2 = new FileOutputStream(outFile, true); //내용 연결
		byte[] byteArray1 = "안녕하세요".getBytes(Charset.forName("UTF-8"));
		os2.write(byteArray1);
		os2.write('\n');
		os2.flush();
		os2.close();

		//#3. n-byte 단위 쓰기 (byte[]의 offset부터 length 개의  byte 데이터를 쓰기)
		OutputStream os3 = new FileOutputStream(outFile, true); //내용 연결
		byte[] byteArray2 = "반갑습니다.".getBytes(Charset.defaultCharset());
		os3.write(byteArray2, 6, 6);

		os3.flush();
		os3.close();

	}
}

chap19_javaio-master\src\sec03_consoleinputoutput\EX01_ConsoleInputObject_1\ConsoleInputObject_1.java"
package sec03_consoleinputoutput.EX01_ConsoleInputObject_1;

import java.io.IOException;
import java.io.InputStream;

public class ConsoleInputObject_1 {
	public static void main(String[] args) throws IOException {

		//InputStream 객체 생성
		InputStream is = System.in;
		int data;
		while((data=is.read())!='\r') {
			System.out.println("읽은 데이터 : "+ (char)data + " 남은 바이트수 : " + is.available());
		}
		System.out.println(data); //\r (13)
		System.out.println(is.read()); //\n (10)

	}
}

chap19_javaio-master\src\sec03_consoleinputoutput\EX02_ConsoleInputObject_2\ConsoleInputObject_2.java"
package sec03_consoleinputoutput.EX02_ConsoleInputObject_2;

import java.io.IOException;
import java.io.InputStream;

public class ConsoleInputObject_2 {
	public static void main(String[] args) throws IOException {

		InputStream is = System.in;

		//#1. 1-byte 단위 읽기
		int data;
		while((data=is.read())!='\r') {
			System.out.print((char)data);
		}
		is.read(); //\n (10)
		System.out.println();
		System.out.println();

		//#2. n-byte 단위 읽기 (byte[]의 처음 위치에서 붙터 읽은 데이터 저장)
		byte[] byteArray1 = new byte[100];
		int count1 = is.read(byteArray1);

		for(int i=0; i<count1; i++)
			System.out.print((char)byteArray1[i]);
		System.out.println(" : count = " + count1);


		//#3. n-byte 단위 읽기 (length 만큼 앞에서부터 읽어와서 byte[] offset위치부터 넣어라)
		byte[] byteArray2 = new byte[8]; //offset+length
		int offset=3;
		int length=5;
		int count2 = is.read(byteArray2, offset, length);
		for(int i=0; i<offset+count2; i++) {
			System.out.print((char)byteArray2[i]);
		}
		System.out.println(" : count = " + count2);
	}
}

chap19_javaio-master\src\sec03_consoleinputoutput\EX03_ConsoleInputObject_3\ConsoleInputObject_3.java"
package sec03_consoleinputoutput.EX03_ConsoleInputObject_3;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;

public class ConsoleInputObject_3 {
	public static void main(String[] args) throws IOException {


		InputStream is = System.in;

		//#2. n-byte 단위 읽기 (byte[]의 처음 위치에서 붙터 읽은 데이터 저장)
		byte[] byteArray1 = new byte[100];
		int count1 = is.read(byteArray1);

		String str1 = new String(byteArray1, 0, count1, Charset.forName("UTF-8"));
		System.out.println(str1);


		//#3. n-byte 단위 읽기 (length 만큼 앞에서부터 읽어와서 byte[] offset위치부터 넣어라)
		byte[] byteArray2 = new byte[9]; //offset+length
		int offset=3;
		int length=6;
		int count2 = is.read(byteArray2, offset, length);

		String str2 = new String(byteArray2, 0, offset+count2, Charset.defaultCharset());
		//String str2 = new String(byteArray2, offset, count2, Charset.defaultCharset());
		System.out.println(str2);
	}
}

chap19_javaio-master\src\sec03_consoleinputoutput\EX04_ConsoleOutputObject_1\ConsoleOutputObject_1.java"
package sec03_consoleinputoutput.EX04_ConsoleOutputObject_1;

import java.io.IOException;
import java.io.OutputStream;

public class ConsoleOutputObject_1 {
	public static void main(String[] args) throws IOException {

		OutputStream os = System.out;

		//#1. 1-byte 단위 쓰기
		os.write('J');
		os.write('A');
		os.write('V');
		os.write('A');
		os.write('\r'); //13 //생략가능
		os.write('\n'); //10 개행 /r/n
		os.flush();


		//#2. n-byte 단위 쓰기 (byte[]의 처음부터 끝까지 데이터를 쓰기)
		byte[] byteArray1 = "Hello!".getBytes();
		os.write(byteArray1);
		os.write('\n');
		os.flush();


		//#3. n-byte 단위 쓰기 (byte[]의 offset부터 length 개의  byte 데이터를 쓰기)
		byte[] byteArray2 = "Better the last smile than the first laughter".getBytes();
		os.write(byteArray2, 7, 8);
		os.flush();

	}
}

chap19_javaio-master\src\sec03_consoleinputoutput\EX05_ConsoleOutputObject_2\ConsoleOutputObject_2.java"
package sec03_consoleinputoutput.EX05_ConsoleOutputObject_2;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;

public class ConsoleOutputObject_2 {
	public static void main(String[] args) throws IOException {

		OutputStream os = System.out;

		//#2. n-byte 단위 쓰기 (byte[]의 처음부터 끝까지 데이터를 쓰기)
		byte[] byteArray1 = "안녕하세요".getBytes(Charset.forName("UTF-8"));
		os.write(byteArray1);
		os.write('\n');
		os.flush();


		//#3. n-byte 단위 쓰기 (byte[]의 offset부터 length 개의  byte 데이터를 쓰기)
		byte[] byteArray2 = "반갑습니다.".getBytes(Charset.defaultCharset());
		os.write(byteArray2, 6, 6);
		os.flush();

	}
}

chap19_javaio-master\src\sec04_filterinputoutputstream\EX01_BufferedInputOutputStream\BufferedInputOutputStream.java"
package sec04_filterinputoutputstream.EX01_BufferedInputOutputStream;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class BufferedInputOutputStream {
	public static void main(String[] args) {
		//#파일 생성
		File orgfile = new File("src\\sec04_filterinputoutputstream\\files\\mycat_origin.jpg");
		File copyfile1 = new File("src\\sec04_filterinputoutputstream\\files\\mycat_copy1.jpg");
		File copyfile2 = new File("src\\sec04_filterinputoutputstream\\files\\mycat_copy2.jpg");

		long start, end, time1, time2;
		//#1. BufferedInputStream, BufferedOutputStream을 사용하지 않는 경우
		start = System.nanoTime();
		try(InputStream is = new FileInputStream(orgfile);
			OutputStream os = new FileOutputStream(copyfile1);){
			//복사하는 코드
			int data;
			while((data=is.read())!=-1) {
				os.write(data);
			}
		} catch(IOException e) {e.printStackTrace();}
		end = System.nanoTime();
		time1= end-start;
		System.out.println("Without BufferedXXXStream : " +time1);

		//#2. BufferedInputStream, BufferedOutputStream을 사용한 경우
		start = System.nanoTime();
		try(InputStream is = new FileInputStream(orgfile);
			BufferedInputStream bis = new BufferedInputStream(is);
			OutputStream os = new FileOutputStream(copyfile2);
			BufferedOutputStream bos = new BufferedOutputStream(os);){
			//복사하는 코드
			int data;
			while((data=bis.read())!=-1) {
				bos.write(data);
			}
		} catch(IOException e) {e.printStackTrace();}
		end = System.nanoTime();
		time2= end-start;
		System.out.println("With BufferedXXXStream : " +time2);

		//사용한 경우와 사용하지 않은 경우 비
		System.out.println("Ratio of with and without : " +time1/time2);
	}
}

chap19_javaio-master\src\sec04_filterinputoutputstream\EX02_DataInputOutputStream\DataInputOutputStream.java"
package sec04_filterinputoutputstream.EX02_DataInputOutputStream;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class DataInputOutputStream {
	public static void main(String[] args) throws IOException {

		//파일 생성
		File dataFile = new File("src/sec04_filterinputoutputstream/files/file1.data");

		//데이터 쓰기 (DataOutputStream)
		try(OutputStream os = new FileOutputStream(dataFile);
			DataOutputStream dos = new DataOutputStream(os);){

			dos.writeInt(35);
			dos.writeDouble(5.8);
			dos.writeChar('A');
			dos.writeUTF("안녕하세요");
			dos.flush();
		}

		//데이터 읽기 (DataInputStream)
		try(InputStream is = new FileInputStream(dataFile);
			DataInputStream dis = new DataInputStream(is);){

			System.out.println(dis.readInt());
			System.out.println(dis.readDouble());
			System.out.println(dis.readChar());
			System.out.println(dis.readUTF());

		}
	}
}

chap19_javaio-master\src\sec04_filterinputoutputstream\EX03_CombineFilterStream\CombineFilterStream.java"
package sec04_filterinputoutputstream.EX03_CombineFilterStream;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class CombineFilterStream {
	public static void main(String[] args) throws IOException {

		//파일 생성
		File dataFile = new File("src/sec04_filterinputoutputstream/files/file2.data");

		//데이터 쓰기 (DataOutputStream)
		try(OutputStream os = new FileOutputStream(dataFile);
			BufferedOutputStream bos = new BufferedOutputStream(os);
			DataOutputStream dos = new DataOutputStream(bos);){

			dos.writeInt(35);
			dos.writeDouble(5.8);
			dos.writeChar('A');
			dos.writeUTF("안녕하세요");
			dos.flush();
		}

		//데이터 읽기 (DataInputStream)
		try(InputStream is = new FileInputStream(dataFile);
			BufferedInputStream bis = new BufferedInputStream(is);
			DataInputStream dis = new DataInputStream(bis);){

			System.out.println(dis.readInt());
			System.out.println(dis.readDouble());
			System.out.println(dis.readChar());
			System.out.println(dis.readUTF());

		}
	}
}

chap19_javaio-master\src\sec04_filterinputoutputstream\EX04_PrintStreamExample\PrintStreamExample.java"
package sec04_filterinputoutputstream.EX04_PrintStreamExample;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;

public class PrintStreamExample {
	public static void main(String[] args) throws FileNotFoundException, IOException {

		//#File 객체 생성
		File outFile1 = new File("src/sec04_filterinputoutputstream/files/PrintStream1.txt");
		File outFile2 = new File("src/sec04_filterinputoutputstream/files/PrintStream2.txt");

		//#1. PrintStream(FileOutputStream(File))
		try(OutputStream os1 = new FileOutputStream(outFile1);
			PrintStream ps = new PrintStream(os1);){

			ps.println(5.8);
			ps.print(3+ " 안녕 "+ 12345 + "\n");
			ps.printf("%d ", 7).printf("%s %f", "안녕", 5.8);
			ps.println();
		} catch(IOException e) {}

		//#2. PrintStream(File)
		try(PrintStream ps = new PrintStream(outFile2);){

			ps.println(5.8);
			ps.print(3+ " 안녕 "+ 12345 + "\n");
			ps.printf("%d ", 7).printf("%s %f", "안녕", 5.8);
			ps.println();
		} catch(IOException e) {}

		//#4. PrintStream ps = System.out
		try(OutputStream os2 = System.out;
			PrintStream ps = new PrintStream(os2)){

			ps.println(5.8);
			ps.print(3+ " 안녕 "+ 12345 + "\n");
			ps.printf("%d ", 7).printf("%s %f", "안녕", 5.8);
			ps.println();
		} catch(IOException e) {}


	}
}

chap19_javaio-master\src\sec05_readerwriter\EX01_FileReaderWriter\FileReaderWriter.java"
package sec05_readerwriter.EX01_FileReaderWriter;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

public class FileReaderWriter {
	public static void main(String[] args) {

		//#파일객체 생성
		File readerWriterFile = new File("src/sec05_readerwriter/files/ReaderWriterFile.txt");

		//#1.FileWiter를 이용한 파일 쓰기 (UTF-8 모드)
		try(Writer writer = new FileWriter(readerWriterFile)){

			writer.write("안녕하세요\n".toCharArray());
			writer.write("Hello");
			writer.write('\r');
			writer.write('\n');
			writer.write("반갑습니다.", 2, 3);
			writer.flush();

		}catch(IOException e) {}

		//#2.FileReader를 이용한 파일 읽기 (UTF-8 모드)
		try(Reader reader = new FileReader(readerWriterFile)){

			int data;
			while((data=reader.read())!=-1) {
				System.out.print((char)data);
			}

		} catch(IOException e) {}
	}
}

chap19_javaio-master\src\sec05_readerwriter\EX02_BufferedReaderWriter\BufferedReaderWriter.java"
package sec05_readerwriter.EX02_BufferedReaderWriter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

public class BufferedReaderWriter {
	public static void main(String[] args) {

		//#파일객체 생성
		File readerWriterFile = new File("src/sec05_readerwriter/files/BufferedFile.txt");

		//#1.FileWiter를 이용한 파일 쓰기 (UTF-8 모드)
		try(Writer writer = new FileWriter(readerWriterFile);
			BufferedWriter bw = new BufferedWriter(writer);	){

			bw.write("안녕하세요\n".toCharArray());
			bw.write("Hello");
			bw.write('\r');
			bw.write('\n');
			bw.write("반갑습니다.", 2, 3);
			bw.flush();

		}catch(IOException e) {}

		//#2.FileReader를 이용한 파일 읽기 (UTF-8 모드)
		try(Reader reader = new FileReader(readerWriterFile);
			BufferedReader br = new BufferedReader(reader);){

			String data;
			while((data=br.readLine())!=null) {
				System.out.println(data);
			}

		} catch(IOException e) {}
	}
}

chap19_javaio-master\src\sec05_readerwriter\EX03_InputStreamReader_1\InputStreamReader_1.java"
package sec05_readerwriter.EX03_InputStreamReader_1;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

public class InputStreamReader_1 {
	public static void main(String[] args) {
		//#파일객체 생성
		File inputStreamReader = new File("src/sec05_readerwriter/files/InputStreamReader.txt");

		//#1.FileReader를 이용한 파일 읽기
		try(Reader reader = new FileReader(inputStreamReader)){

			int data;
			while((data=reader.read())!=-1) {
				System.out.print((char)data);
			}

		} catch(IOException e) {}
		System.out.println();System.out.println();

		//#2.FileInputStream + InputStreamReader를 이용한 파일 읽기
		try(InputStream is = new FileInputStream(inputStreamReader);
			InputStreamReader isr = new InputStreamReader(is, "MS949");){

			int data;
			while((data=isr.read())!=-1) {
				System.out.print((char)data);
			}
			System.out.println("\n"+isr.getEncoding());//MS949


		} catch(IOException e) {}
	}
}

chap19_javaio-master\src\sec05_readerwriter\EX04_InputStreamReader_2\InputStreamReader_2.java"
package sec05_readerwriter.EX04_InputStreamReader_2;

import java.io.IOException;
import java.io.InputStreamReader;

public class InputStreamReader_2 {
	public static void main(String[] args) {

		//#1. 콘솔입력 (UTF-8)
		try {
			InputStreamReader isr = new InputStreamReader(System.in, "UTF-8");
			int data;
			while((data=isr.read())!='\r') {
				System.out.print((char)data);
			}
			System.out.println("\n"+isr.getEncoding());

		} catch (IOException e) {}

		//#3. 콘솔입력 (MS949)
		try {
			InputStreamReader isr = new InputStreamReader(System.in, "MS949");
			int data;
			while((data=isr.read())!='\r') {
				System.out.print((char)data);
			}
			System.out.println("\n"+isr.getEncoding());

		} catch (IOException e) {}
	}
}

chap19_javaio-master\src\sec05_readerwriter\EX05_OutputStreamWriter_1\OutputStreamWriter_1.java"
package sec05_readerwriter.EX05_OutputStreamWriter_1;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

public class OutputStreamWriter_1 {
	public static void main(String[] args){


		//#1. FileWriter를 이용하여 데이터 쓰기 (디폴트 (UTF-8))
		File outputStreamWriter1 = new File("src/sec05_readerwriter/files/OutputStreamWiter1.txt");
		try(Writer writer = new FileWriter(outputStreamWriter1);){
			writer.write("OutputStreamWriter1 예제파일입니다.\n".toCharArray());
			writer.write("한글과 영문이 모두 포함되어 있습니다.");
			writer.write('\n');
			writer.write("Good Bye!!!\n\n");
			writer.flush();
		} catch(IOException e) {}

		//#2. FileWriter를 이용하여 데이터 쓰기 (디폴트 (UTF-8) --> MS949 파일 생성)

		File outputStreamWriter2 = new File("src/sec05_readerwriter/files/OutputStreamWiter2.txt");
		try(OutputStream os = new FileOutputStream(outputStreamWriter2, false);
			OutputStreamWriter osw = new OutputStreamWriter(os, "MS949");){

			osw.write("OutputStreamWriter1 예제파일입니다.\n".toCharArray());
			osw.write("한글과 영문이 모두 포함되어 있습니다.");
			osw.write('\n');
			osw.write("Good Bye!!!\n\n");
			osw.flush();

			System.out.println(osw.getEncoding()); //MS949

		} catch(IOException e) {}

	}
}

chap19_javaio-master\src\sec05_readerwriter\EX06_OutputStreamWriter_2\OutputStreamWriter_2.java"
package sec05_readerwriter.EX06_OutputStreamWriter_2;

import java.io.IOException;
import java.io.OutputStreamWriter;

public class OutputStreamWriter_2 {
	public static void main(String[] args) {

		//#1. 콘솔출력 1 (디폴트 : UTF-8 --> UTF-8)
		try {
			OutputStreamWriter osw = new OutputStreamWriter(System.out, "UTF-8");
			osw.write("OutputStreamWriter를 이용한\n".toCharArray());
			osw.write("콘솔출력 예제입니다. \n한글과 영문이 모두 포함되어 있습니다.");
			osw.write("\n");
			osw.write("Good Bye!!!\n");
			osw.flush();
			System.out.println(osw.getEncoding()); //UTF-8

		} catch(IOException e) {}
		System.out.println();

		//#1. 콘솔출력 2 (디폴트 : UTF-8 --> MS949)
		try {
			OutputStreamWriter osw = new OutputStreamWriter(System.out, "MS949");
			osw.write("OutputStreamWriter를 이용한\n".toCharArray());
			osw.write("콘솔출력 예제입니다. \n한글과 영문이 모두 포함되어 있습니다.");
			osw.write("\n");
			osw.write("Good Bye!!!\n");
			osw.flush();
			System.out.println(osw.getEncoding()); //UTF-8

		} catch(IOException e) {}
		System.out.println();


	}
}

chap19_javaio-master\src\sec05_readerwriter\EX07_PrintWriterExample\PrintWriterExample.java"
package sec05_readerwriter.EX07_PrintWriterExample;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriterExample {
	public static void main(String[] args) {

		//파일객체 생성
		File printWriter1 = new File("src/sec05_readerwriter/files/printWriter1.txt");
		File printWriter2 = new File("src/sec05_readerwriter/files/printWriter2.txt");
		File printWriter3 = new File("src/sec05_readerwriter/files/printWriter3.txt");

		//#1. PrintWriter(File file)
		try(PrintWriter pw = new PrintWriter(printWriter1);){
			pw.println("PrintWriter 예제#1");
			pw.println(13);
			pw.println(5.8);
			pw.print("안녕하세요! ");
			pw.println("반갑습니다.");
			pw.printf("%d", 7).printf("%s %f", "감사", 3.7);
		} catch(IOException e) {}

		//#2. PrintWriter(OutputStream os)
		try(PrintWriter pw = new PrintWriter(new FileOutputStream(printWriter2));){
			pw.println("PrintWriter 예제#2");
			pw.println(13);
			pw.println(5.8);
			pw.print("안녕하세요! ");
			pw.println("반갑습니다.");
			pw.printf("%d", 7).printf("%s %f", "감사", 3.7);
		} catch(IOException e) {}


		//#3. PrintWriter(Writer w)
		try(PrintWriter pw = new PrintWriter(new FileWriter(printWriter3));){
			pw.println("PrintWriter 예제#3");
			pw.println(13);
			pw.println(5.8);
			pw.print("안녕하세요! ");
			pw.println("반갑습니다.");
			pw.printf("%d", 7).printf("%s %f", "감사", 3.7);
		} catch(IOException e) {}


		//#4. PrintWriter(System.out)

		PrintWriter pw = new PrintWriter(System.out, true);
		pw.println("PrintWriter 예제#4");
		pw.println(13);
		pw.println(5.8);
		pw.print("안녕하세요! ");
		pw.println("반갑습니다.");
		pw.printf("%d", 7).printf("%s %f", "감사", 3.7);

	}
}

```
